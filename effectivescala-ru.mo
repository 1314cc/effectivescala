<a href="http://github.com/twitter/effectivescala"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

<h1 class="header">Effective Scala</h1>
<address>Marius Eriksen, Twitter Inc.<br />marius@twitter.com (<a href="http://twitter.com/marius">@marius</a>)<br /><br />[translated by Eugene Sysmanov(<a href="https://github.com/appigram">@appigram</a>)]</address>

<h2>Table of Contents</h2>

.TOC


<h2>Другие языки</h2>
<a href="index.html">English</a>
<a href="index-ja.html">日本語</a>

## Введение

[Scala][Scala] является одним из основных языков программирования, который испоьзуется в Twitter. Большая часть нашей инфрастуктуры написана на Scala и [у нас есть несколько крупных библиотек](http://github.com/twitter/) поддерживается нами.

Scala не только очень эффективный, но также и большой язык, полученный нами опыт, научил нас быть очень осторожным при его использовании на практике в своем приложении. Где скрыты подводные камни? Какие особенности стоит использвать, а от каких отказаться? Когда мы можем использовать «чисто функциональный стиль», а когда его следует избегать? Другими словами: что мы используем, чтобы быть более эффективными при использовании языка? Это руководство пытается передать наш опыт в коротких заметках, представляя набор *лучших практик*. Мы используем Scala для создания высококачественных услуг, которые представляют собой распределенные системы - наше мнение возможно будет предвзято - но большинство советов здесь должны работать без проблем и 
при переносе на другие системы. Все это не истина в последней инстанции, и отклонение должно быть вполне приемлимым.


Scala предоставляет множество инструментов, которые позволяют кратко описывать свои действия. Если мы меньше будем набирать символов, значит меньше придется читать, а значит исходный код будет прочитан быстрее, из этого следует, что краткость повышает ясность. Однако краткость может быть и тупым инструментом, который может оказать обратный эффект: вслед за правильностью, всегда нужно думать о читателе.

Немного, о *программе на Scala*. Вы не пишете код ни на Java, ни на Haskell, ни на Python; написание Scala-программы отличается от написания в любом из этих языков. Для того чтобы использовать язык эффективно, вы должны описать свои проблемы, в терминах этого языка. Вас никто не принуждает использовать программу, написанную на Java, в Scala, в большинстве случаев она будет уступать оригиналу.

Данный документ не введение в язык Scala, мы предполагаем, что читатель
знаком с языком. Вот некоторые ресурсы для обучения языку Scala:

* [Scala School](http://twitter.github.com/scala_school/)
* [Learning Scala](http://www.scala-lang.org/node/1305)
* [Learning Scala in Small Bites](http://matt.might.net/articles/learning-scala-in-small-bites/)

Данные статьи - это живой документ, который будет меняться с учетом наших текущих "лучших практик", но его основные идеи вряд ли изменятся: писать код, который всегда легко читаем; писать универсальный код, но не в ущерб
ясности; пользоваться простыми функциями языка, которые обладают большой
мощью, но избегать эзотерических функций (особенно в системе типов).
Прежде всего, всегда нужно находить компромиссы в том, что вы делаете.Сложность языка требуется в комплексных реализациях, потому что она порождает сложность: в рассуждениях, в семантике, во взаимодействия между особенностями системы, а также в понимании между вашими сотрудниками. Таким образом, трудность является производной сложности - вы всегда должны убедиться, что ее полезность превышает ее стоимость.

И получайте удовольствие.

## Форматирование

Специфические способы *форматирования кода* - пока они практичны -
не имеют большого значения. По определению, стиль не может быть хорошим или плохим, почти все определяет личное предпочтение. Однако, *последовательное* применение одних и тех же правил форматирования будет почти всегда увеличивать удобочитаемость. Читатель, уже знакомый с данным стилем, не должен разбираться в еще одном наборе местных соглашений или расшифровать еще одну часть языковой грамматики.

Это имеет особое значение для Scala, поскольку у его грамматики высокий уровень вхождения. Один говорящий пример - вызов метода: Методы
может быть вызваны с помощью "`.`", либо с использованием пробела, либо без круглой скобки для не возвращающих значений или унарных методов, с круглой скобкой для них, и так далее. Кроме того, различные стили вызова метода оставляют двусмысленность в его грамматике! Конечно, последовательное применение тщательно выбранного набора правил форматирования решит большую часть двусмысленности и для человека и для машины.

Мы придерживаемся [Правила форматирования в языке Scala] (http://docs.scala-lang.org/style/) и дополнительно следующих правил.

### Пробельные символы

При отступе используется 2 пробельных символа. Мы стараемся избегать строк, длиной более 100 символов. Мы используем одну пустую строку между методом, классом и определениями объекта.

### Именование

<dl class="rules">
<dt>Используйте короткие имена для небольших областей видимости</dt>
<dd>Применяйте <code>i</code>,<code>j</code> и <code>k</code> и подобне переменные в циклах </dd>
<dt>Используйте длинные имена для больших областей видимости</dt>
<dd>Внешние API должны иметь длинные и понятные имена, которые придают смысл.
<code>Future.collect</code> вместо <code>Future.all</code>.
</dd>
<dt>Используйте стандартные сокращения, и откажитесь от эзотерических</dt>
<dd>
Всем известны <code>ok</code>, <code>err</code> или <code>defn</code>,а вот <code>sfri</code> используется не так часто.
</dd>
<dt>Не используйте одни и теже имена для различных целей</dt>
<dd>Применяйте <code>val</code></dd>
<dt>Избегайте использования <code>`</code> для перегрузки зарезервированных имен.</dt>
<dd>Используйте <code>typ</code> вместо <code>`type</code>`</dd>
<dt>Используйте имени active для операций с побочными эффектами</dt>
<dd><code>user.activate()</code> вместо <code>user.setActive()</code></dd>
<dt>Используйте описательные имен для методов, которые возвращают значения</dt>
<dd><code>src.isDefined</code> вместо <code>src.defined</code></dd>
<dt>Не используйте у геттеров(getter) префикс <code>get</code></dt>
<dd>В соответствии с предыдущим правилом: лучше применять <code>site.count</code> вместо <code>site.getCount</code></dd>
<dt>Не используйте повторно имена, которые уже есть в пакете или в названии объекта</dt>
<dd>Предпочтительно:
<pre><code> object User {
   def get(id: Int): Option[User]
}</code></pre>вместо
<pre><code>object User {
   def getUser(id: Int): Option[User]
}</code></pre>Они являются избыточными при использовании: <code>User.getUser</code> дает не больше информации, чем <code>User.get</code>.
</dd>
</dl>

### Импортирование

<dl class="rules">
<dt>Располагайте строки импорта в алфавитном порядке</dt>
<dd>Так их проще определить визуально, и так проще для автоматизации.</dd>
<dt>Используйте фигурные скобки при импортировании нескольких имен из пакета</dt>
<dd><code>import com.twitter.concurrent.{Broker, Offer}</code></dd>
<dt>Используйте символ подчеркивания, когда импортируйте более 6 имен</dt>
<dd>например: <code>import com.twitter.concurrent._</code>
<br />Не применяйте его без оглядки, некоторые пакеты экспортируют слишком много имен</dd>
<dt>Когда используете коллекции, уточняйте имена при импортировании <code>scala.collection.immutable</code> и/или <code>scala.collection.mutable</code></dt>
<dd>Изменяемые и неизменяемые коллекции имеют двойные имена. Уточнение имен сделает очевидным для читателя какой вариант используется (например "<code>immutable.Map</code>")</dd>
<dt>Не используйте относительный импорт из других пакетов</dt>
<dd>Избегайте <pre><code>import com.twitter
import concurrent</code></pre> в пользу более одназначного <pre><code>import com.twitter.concurrent</code></pre></dd>
<dt>Располагайте строки импорта вверху файла</dt>
<dd>Читатель может обратится ко всем строкам импорта в одном месте</dd>
</dl>

### Фигурные скобки

Фигурные скобки используются для создания сложных выражений (они служат другим целям в "языковом модуле"), где значение соответствующего выражения является последним выражением в списке. Старайтесь не использовать скобки для простых выражений; пишите

	def square(х: Int) = х*х

.LP, вместо

	def square(х: Int) = {
 	  х * х
	}

.LP, хотя это может быть привлекательным, чтобы отличить тело метода синтаксически. Первый вариант имеет меньший беспорядок и его легче читать. <em>Избегайте синтаксических церемоний</em>, если это не уточняется.

### Сравнение с образцом

Используйте сравнение с образцом в определении функций, когда это необходимо;
Вместо

	list map { item =>
	  item match {
	    case Some(x) => x
	    case None => default
	  }
	}

.LP лучше написать так

	list map {
	  case Some(x) => x
	  case None => default
	}

.LP ясно, что элементы списка в настоящее время отображаются более ясно &mdash; дополнительно уточнять ничего не нужно.

### Комментарии

Используйте [ScalaDoc](https://wiki.scala-lang.org/display/SW/Scaladoc), чтобы предоставлять документацию по API, Используйте следующий стиль:

	/**
	 * ServiceBuilder builds services 
	 * ...
	 */
	 
.LP <em>вместо</em>стандартного стиля ScalaDoc:

	/** ServiceBuilder builds services
	 * ...
	 */

Не прибегайте к ASCII искусству или другим визуальным украшениям. Документируйте API, но не добавляйте ненужных комментариев. Если вы добавляете комментарии, чтобы объяснить поведение вашего кода, сначала спросите себя, может ли код быть переписан так, чтобы стало очевидным, что он делает. Предпочитайте "Очевидно, это работает" вместо "Это работает, очевидно" (цитата Энтони Хоара).

(прим. переводчика: "Есть два метода создания программного обеспечения. Один из них — сделать программу настолько простой, что, очевидно, в ней нет недостатков. И другой, сделать приложение настолько сложным, что в нем невидно явных недостатков." - [Энтони Хоар](http://ru.wikipedia.org/wiki/Хоар,_Чарльз_Энтони_Ричард) выдержка из лекции, [Премия Тьюринга](http://amturing.acm.org/award_winners/hoare_4622167.cfm))

## Типы и обобщенные типы

Основной целью системы типов является выявление ошибок программирования. Система типов эффективно обеспечивает определенную форму статической проверки, что позволяет нам получать определенный набор неизменных параметров о нашем коде, который компилятор может проверить. Система типов конечно обеспечивает и другие преимущества, но проверка ошибок является ее основной целью.

Наше использование системы типов должно отражать эту цель, но мы должны не забывать и о читателе: разумное использование типов может служить повышением ясности, быть заумным только запутывать остальных.

Мощная система типов в Scala является результатом общих усилий академических опытов и разработок (например, [Scala программирование на уровне системы типов] (http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/)).
В то время как это увлекательная академическая статья, эти методы редко находят полезное применение в реальном коде приложений. Их можно избегать.

### Возвращаемый тип аннотаций

В то время как Scala позволяет опускать их, такие аннотации обеспечивают хорошую документацию: это особенно важно для публичных методов. Там где возвращаемый тип метода очевиден, их можно опустить.

Это особенно важно при создании экземпляров объектов с миксинами(Mixins), так как компилятор Scala создает тип синглтон(singleton) для них. Например, `make` в примере:

	trait Service
	def make() = new Service {
	  def getId = 123
	}

.LP <em>не</em> имеет возвращаемого типа <code>Service</code>, компилятор создает <code>Object with Service{def getId: Int}</code>. Вместо того, чтобы использовать явную аннотацию:

	def make(): Service = new Service{}

В настоящее время автор свободен смешивать множество трейтов(traits) без изменения общедоступного типа `make`, делая возможность легче управлять обратной совместимостью.

### Противоречие

Противоречие возникает, когда обобщеные типы объединены с выделением подтипов. Они определяют как выделение подтипов типа *contained* относится к выделению подтипов типа *container*. Потому что Scala имеется определенное соглашение по комментированию, авторы общих библиотек - особенно коллекций -
должны быть активными комментаторами. Такие комментарии важны для
удобства работы с общим кодом, но неверные комментарии могут быть опасны.

Инварианты - усовершенствованный, но необходимый компонент системы типов Scala,и должны использоваться широко (и правильно), поскольку это помогает приложению в выделении подтипов.

*Коллекции Immutable должны быть зависимыми(covariant)*. Методы, которые получают
contained тип должны быть "понижены"("downgrade") до соответствующей коллекции:
	
	trait Collection[+T] {
	  def add[U >: T](other: U): Collection[U]
	}

*Mutable коллекции должны быть неизменяемы(invariant)*. Зависимость обычно бессмыслена с изменяемыми(mutable) коллекциями. Будем считать

	trait HashSet[+T] {
	  def add[U >: T](item: U)
	}

.LP и следующую иерархию типов:

	trait Mammal
	trait Dog extends Mammal
	trait Cat extends Mammal

.LP Если у меня сейчас есть хеш-коллекцию из объектов Собака

	val dogs: HashSet[Dog]

.LP создаем хеш-коллекцию Млекопитающих и добавляем в колллекцию объект Кошка

	val mammals: HashSet[Mammal] = dogs
	mammals.add(new Cat{})

.LP Теперь эта хеш-коллекция не является коллекцией объектов Собака！

(прим. переводчика: Поддробнее о [ковариантности и контрвариантности](http://chabster.blogspot.com/2008/01/type-system-covariance-and.html))

<!--
  *	when to use abstract type members?
  *	show contravariance trick?
-->

### Псевдонимы типов

Используйте псевдонимы типов, когда они позволяют удобное именование или разъяснение цели, но не искажают типы, которые очевидны.

	() => Int

.LP данная запись более понятна чем

	type IntMaker = () => Int
	IntMaker

.LP так как это короче и используется общий тип, однако

	class ConcurrentPool[K, V] {
	  type Queue = ConcurrentLinkedQueue[V]
	  type Map   = ConcurrentHashMap[K, Queue]
	  ...
	}

.LP более полезно, так как это передает цель и улучшает краткость.

Не используйте разделение на подклассы, когда псевдоним делает тоже самое

	trait SocketFactory extends (SocketAddress => Socket)
	
.LP <code>SocketFactory</code> <em>это</em> функция которая создает <code>Socket</code>. Использование псевдонима

	type SocketFactory = SocketAddress => Socket

.LP более правильно. Теперь мы можем обеспечить функциональные идентификаторы для значений типа<code>SocketFactory</code>,а также использовать композицию функций:

	val addrToInet: SocketAddress => Long
	val inetToSocket: Long => Socket

	val factory: SocketFactory = addrToInet andThen inetToSocket

Псевдонимы типа связаны с именами, которые стоят выше в иерархии при помощи пакетных объектов:

	package com.twitter
	package object net {
	  type SocketFactory = (SocketAddress) => Socket
	}

Обратите внимание на то, что псевдонимы, это не новые типы - они эквивалентны
синтаксической замене типа новым именем.

### Неявные преобразования

Неявные преобразования являются мощной возможностью системы типов, но они должны использоваться экономно. Они усложняют правила преобразования и делают это достаточно трудно -- простым лексическим сравнением -- чтобы понять, что на самом деле происходит. Обычно неявные преобразования используются в следуюей ситуации:

* Расширение или добавление коллекций стиля программирования Scala
* Адаптация или расширение объекта (шаблон "pimp my library")
* Использование для *повышения безопасности типов*, предоставляя ограниченный набор данных
* Чтобы представить данные типа (typeclassing)
* Для `Манифестов`

Если действительно хотите использовать неявные преобразования, всегда спрашивайте себя, есть ли способ достигнуть той же цели без их помощи.

Не используйте неявные преобразования, чтобы сделать автоматическое преобразование между похожими типами данных (например, преобразование списка в поток); это лучше сделать явно, потому что у типов есть различная семантика, и читатель должен остерегаться подобных реализаций.

## Коллекции

У Scala есть универсальная, очень богатая, мощная, и прекрасно составленная библиотека коллекций; коллекции - высокоуровневые реализации и они представляют собой большой набор различный операций. Много действий с коллекциями и их преобразования могут быть выражены кратко и четко, но небрежное применение функций может привести к противоположному результату. Каждый Scala-программист должен прочитать [Сollections design document](http://www.scala-lang.org/docu/files/collections-api/collections.html);
он обеспечит большее понимание при работе с библиотекой коллекций Scala.

Всегда используйте самую простую коллекцию, которая соответствует вашим потребностям отребностям.

### Иерархия

Библиотека коллекций очень большая: в дополнение к сложной
иерархии - корнем которой является `Traversable[T]` - существуют
`immutable` и `mutable` варианты для большинства коллекций. Несмотря на сложность, на следующей диаграмме содержится важная
различия между `immutable` и `mutable` иерархиями

<img src="coll.png" style="margin-left: 3em;" />
.cmd
pic2graph -format png >coll.png <<EOF 
boxwid=1.0

.ft I
.ps +9

Iterable: [
	Box: box wid 1.5*boxwid
	"\s+2Iterable[T]\s-2" at Box
]

Seq: box "Seq[T]" with .n at Iterable.s + (-1.5, -0.5)
Set: box "Set[T]" with .n at Iterable.s + (0, -0.5)
Map: box "Map[T]" with .n at Iterable.s + (1.5, -0.5)

arrow from Iterable.s to Seq.ne
arrow from Iterable.s to Set.n
arrow from Iterable.s to Map.nw
EOF
.endcmd

.LP <code>Iterable[T]</code> - это любая коллекция, элементы которой могут быть итерированы, она имеет метод <code>iterator</code>(а также <code>foreach</code>).<code>Seq[T]</code>- это коллекция, элементы которой <em>отсортированы</em>,<code>Set[T]</code>- является аналогом математического множества (неупорядоченная коллекция уникальных элементов), и <code>Map[T]</code> - который представляет собой неотсортированный ассоциативный массив.

### Применение

* Предпочитительнее использовать immutable коллекции.* Они применимы в большинстве случаев, и делают программу проще и прозрачнее в понимании,а также потокобезопасной по умолчанию.

* Используйте `mutable` пространство имен явно.* Не импортируйте
`scala.collection.mutable._` и ссылку на `set`, лучше сделать так

	import scala.collections.mutable
	val set = mutable.Set()

.LP потому что становится чсно, что используется mutable вариант

* Используйте стандартный конструктор для коллекций.* Всякий раз, когда вам нужна упорядоченная последовательность (и не обязательно связаный список), используйте конструктор `Seq()`, и тому подобное:

	val seq = Seq(1, 2, 3)
	val set = Set(1, 2, 3)
	val map = Map(1 -> "one", 2 -> "two", 3 -> "three")

.LP Этот стиль отделяет семантику коллекции от ее реализации, позволяя библиотеке коллекций использовать наиболее подходящий тип: если вам нужна <code>Map</code>, не обязательно использовать <a href="http://ru.wikipedia.org/wiki/Красно-чёрное_дерево">Красно-черное дерево(Red-Black Tree)</a>. Кроме того, стандартные конструкторы будут часто использовать специализированные представления: например, <code>Map()</code> будет использовать объект с 3 полями для карт с 3 ключами(<a href="http://www.scala-lang.org/api/current/scala/collection/immutable/Map$$Map3.html"><code>Map3</code></a>).

В заключение к сказанному выше: в ваших собственных методах и конструкторах *старайтесь использовать самую универсальную коллекцию*. Обычно это сводится к одной из приведенных: `Iterable`, `Seq`, `Set`, или `Map`. Если ваш метод нуждается в последовательности, используйте `Seq[T]`, а не `List [T]`.

<!--
something about buffers for construction?
anything about streams?
-->

### Стиль

Функциональное программирование призывает к цепочечным преобразованиям
immutable коллекций для получения желаемого результата. Это часто
приводит к очень коротким решениям, но также может ввести в заблуждение
читателя - часто трудно понять намерения автора, или отслеживать все промежуточные результаты, которые подразумеваются. Например,
предположим, что мы хотим собрать голоса для разных языков программирования
из набора (язык, число голосов), показывая их, в порядке убывания числа голосов, мы могли бы написать:

	val votes = Seq(("scala", 1), ("java", 4), ("scala", 10), ("scala", 1), ("python", 10))
	val orderedVotes = votes
	  .groupBy(_._1)
	  .map { case (which, counts) => 
	    (which, counts.foldLeft(0)(_ + _._2))
	  }.toSeq
	  .sortBy(_._2)
	  .reverse

.LP это кратко и правильно, но почти любому читателю нужно время, чтобы восстановить в голове первоначальные намерения автора. Стратегия, которая призвана уточнить решение <em>использование промежуточных результатов и параметров</em>:

	val votesByLang = votes groupBy { case (lang, _) => lang }
	val sumByLang = votesByLang map { case (lang, counts) =>
	  val countsOnly = counts map { case (_, count) => count }
	  (lang, countsOnly.sum)
	}
	val orderedVotes = sumByLang.toSeq
	  .sortBy { case (_, count) => count }
	  .reverse

.LP код является почти столь же кратким, но гораздо более четко описывает происходящие превращения (именованные промежуточные значения), и структуры данных с которыми работает программа (именованные параметры). Если вы беспокоитесь о засорении пространства имен, применяя этот стиль, используйте группировку выражений с помощью <code>{}</code>:

	val orderedVotes = {
	  val votesByLang = ...
	  ...
	}


### Производительность

Высокоуровневые библиотеки коллекций (как обычно и с высокоуровневыми конструкциями), делают определение производительности более трудоемким:
чем дальше вы отклоняетесь от указания непосредственных команд компьютеру - другими словами, императивного стиля - тем тяжелее предсказать точное значение производительности участка кода. Обосновать правильность, однако, обычно проще; удобочитаемость также улучшается. Со Scala ситуация осложнена средой исполнения Java; Scala скрывает операции упаковки/распаковки от нас, но они могут серьезно влиять на производительность или оказывать негативное воздействие.

Прежде, чем сфокусироваться на низкоуровневых деталях, удостоверьтесь, что используете коллекцию, подходящую в данном случае. Удостоверьтесь, что ваша структура данных не имеет неожиданной асимптотической сложности. Сложности для разных Scala коллекций описаны [здесь](http://www.scala-lang.org/docu/files/collections-api/collections_40.html).

Первое правило оптимизации производительности состоит в том, чтобы понять *почему* ваше приложение медленно работает. Не стоит действовать без оглядки; профилируйте^ [Yourkit] (http://yourkit.com) - неплохой профилировщик] приложение до начала дальнейших действий. Фокусируйтесь сначала на интенсивно используемых циклах и больших структурах данных. Чрезмерные усилия на оптимизацию обычно тратятся впустую. Помните принцип Кнута: "Преждевременная оптимизация - корень все зол."

Очень часто целесообразно использовать низкоуровневые коллекции в ситуациях где требуется лучшая производительность или иметь задел эффективности на будущее. Используйте массивы вместо списков для больших последовательностей (неизменяемая `Vector` коллекция обеспечивает похожий прозрачный интерфейс для массивов); и используйте буферы вместо конструирования последовательности, когда стоят вопросы производительности.

### Java Коллекции

Используйте `scala.collection.JavaConverters` для взаимодействия с коллекциями Java. Эта коллекция неявно добавляет методы преобразования `asJava` и `asScala`. Их использование гарантирует, что такие преобразования являются явными, помогая
читателю:

	import scala.collection.JavaConverters._
	
	val list: java.util.List[Int] = Seq(1,2,3,4).asJava
	val buffer: scala.collection.mutable.Buffer[Int] = list.asScala

## Параллелизм

Современные сервисы обладают высоким уровнем параллелизма - все серверы выполняют 10-100 тысяч одновременных операций - и их обработка подразумевают сложность, которая является центральной темой в надежных программных системах.

*Потоки* являются средством выражения параллелизма: они дают вам независимые контексты выполнения с общей разделяемой памятью, которые управляются операционной системой. Тем не менее, создание потоков является затратной операцией в Java и этим ресурсом необходимо управлять, как правило, с использованием пулов. Это создает дополнительные сложности для программиста, а также обладает высокой степенью связности: трудно отделить логику приложения от используемых им основных ресурсов.

Эта сложность особенно заметна при создании сервисов, которые
имеют высокую степень параллелизма: каждый приходящий результат запроса в множество всех запросов на каждый уровень системы. В таких системах, пулы потоков должны быть организованы таким образом, чтобы они быди сбалансированы
в зависимости от количества запросов на каждом уровне: беспорядок в одном пуле потоков негативно влияет на другие.

Надежная система должна также не упускать из виду тайм-ауты и отмены, оба этих элемента требуют введения дополнительного  «контроля» потоков, тем самым усложняя проблему еще больше. Заметим, что если бы потоки были более дешевыми, то эти проблемы бы уменьшились: нет необходимости в пулах, тайм-аут потоков мог бы быть отброшен, и никаких дополнительных ресурсов
для управления не потребовалось бы.

Таким образом, управление ресурсами ставит под угрозу модульность.

### Futures

Используйте futures(актор с возможностью блокировки создающего его потока, если создающий поток запросил результат вычисления - прим. переводчика) для управления параллелизмом. Они позволяют отделить параллельные операции от управления ресурсами: например, [Finagle][Finagle] объединяет параллельные операции в несколько потоков эффективным
образом. Scala имеет легковесный синтаксис замыканий, поэтому futures вводят немного синтаксического сахара, и они становятся более популярны среди программистов.

Futures позволяют программисту выразить параллельные вычисления в декларативном стиле, скомпоновать, и управлять источником ошибки. Эти качества убедили нас в том, что они особенно хорошо подходят для использования в функциональных языках программирования, где подобный стиль поощряется.

*Изменяйте futures вместо создания собственных.* Future
преобразования позволяют поймать ошибку, определить сигнал об отмене, и освобождает программиста от мысли, о релизации модели памяти в Java. Даже осторожный программист может написать следующую выдачу RPC последовательности из 10 элементов, а затем напечатать результаты:

	val p = new Promise[List[Result]]
	var results: List[Result] = Nil
	def collect() {
	  doRpc() onSuccess { result =>
	    results = result :: results
	    if (results.length < 10)
	      collect()
	    else
	      p.setValue(results)
	  } onFailure { t =>
	    p.setException(t)
	  }
	}

	collect()
	p onSuccess { results =>
	  printf("Got results %s\n", results.mkString(", "))
	}

Программист должен убедиться, что ошибки RPC распространяются,
смешивая код и контроль потока выполнения; хуже того, этот код неверен! Без объявления переменной `results`, мы не можем гарантировать, что `results` содержит предыдущее значение на каждой итерации. Модель памяти Java не так проста, но, к счастью, мы можем избежать всех этих ошибок с помощью
декларативного стиль:

	def collect(results: List[Result] = Nil): Future[List[Result]] =
	  doRpc() flatMap { result =>
	    if (results.length < 9)
	      collect(result :: results)
	    else
	      result :: results
	  }

	collect() onSuccess { results =>
	  printf("Got results %s\n", results.mkString(", "))
	}

Мы используем `flatMap` в последовательности операций и сохраняем результат в список, пока мы производим вычисления. Это общая идея функциональных языков программирования
реализована в Futures. Для этого требуется меньше шаблонов, появляется меньше ошибок, а также читается лучше.

*Используйте Futures комбинаторы*. `Future.select`, `Future.join`, и `Future.collect` реализуют общие шаблоны при работе над несколькими Futures, которые должны быть объединены.

### Коллекции

С параллельными коллекциями связано множество мнений,
тонкостей, догм, страха, неуверенности и сомнения. В большинстве практических ситуаций, они не являются проблемой: Всегда начинайте с самой простой, самой скучной, и в основном
стандартной коллекции, которая служит поставленной цели. Не прикасайтесь к параллельной коллекции до того как вы *знаете*, что синхронизированный вариант коллекции не работает: JVM имеет современные механизмы, чтобы сделать синхронизацию дешевой операцией, так что их эффективность может вас удивить.

Если необходимо использовать неизменяемую коллекцию, используйте - она совершенно прозрачна, поэтому рассуждать о них в контексте параллельных вычислений очень просто. Изменения в незменяемых коллекциях, как правило, выполняются путем обновления ссылки на текущее значение (в `var` ячейке или
`AtomicReference`). Необходимо соблюдать осторожность, чтобы применять это корректно: атомы должны быть повторно объявлены, и `переменные` должны быть объявлены на лету в порядке их объявления в других потоках.

Изменяемые параллельные коллекции имеют сложную семантику, и используют тонкости модели памяти в Java, поэтому убедитесь, что вы понимаете последствия - особенно по отношению к использованию обновлений - прежде чем начинать использовать их. Синхронные коллекции тоже лучший вариант: операции, такие как `getOrElseUpdate` не могут быть правильно реализованы для параллельных коллекций, и создание сложных коллекций особенно подвержено ошибкам.

<!--

use the stupid collections first, get fancy only when justified.

serialized? synchronized?

blah blah.

Async*?

-->


## Управляющие структуры

Программы в функциональном стиле, как правило, требуют меньше традиционных управляющих структур, и читать код лучше, когда он написан в декларативном стиле. Это обычно означает, разделение вашей логики на несколько небольших методов или функций, и склеивание их вместе с `match` выражениями. Функциональные программы также имеют тенденцию быть более
ориентированными на выражения: ветви условных выражений для значений того же типа, `for (..) yield` вычисления включений, и рекурсия являются обычным делом.

### Рекурсия

*Формулировка проблемы в терминах рекурсии обычно упрощает ее*, и если применяется оптимизация хвостовой рекурсии (которая может быть проверена с помощью аннотации `@tailrec`), компилятор преобразует ​​код в обычный цикл.

Рассмотрим довольно стандартную императивную реализацию кучи <span class = "algo">fix-down</span>:

	def fixDown(heap: Array[T], m: Int, n: Int): Unit = {
	  var k: Int = m
	  while (n >= 2*k) {
	    var j = 2*k
	    if (j < n && heap(j) < heap(j + 1))
	      j += 1
	    if (heap(k) >= heap(j))
	      return
	    else {
	      swap(heap, k, j)
	      k = j
	    }
	  }
	}

Каждый раз, при входе в цикл, мы работаем с состоянием предыдущей итерации. Значением каждой переменной является результат вычисления функции определенной ветви выполнения, и он возвращается в середине цикла, если был найден верный результат вычисления (внимательный читатель найдет похожие
аргументы в Дейкстры ["О вреде оператора Go To"](http://www.vspu.ac.ru/~chul/dijkstra/goto/goto.htm)).

Рассмотрим реализацию (хвостовой) рекурсии^[Из [Finagle's heap balancer](https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/loadbalancer/Heap.scala#L41)]:

	@tailrec
	final def fixDown(heap: Array[T], i: Int, j: Int) {
	  if (j < i*2) return
	
	  val m = if (j == i*2 || heap(2*i) < heap(2*i+1)) 2*i else 2*i + 1
	  if (heap(m) < heap(i)) {
	    swap(heap, i, m)
	    fixDown(heap, m, j)
	  }
	}

.LP здесь каждая итерация начинается с <em>чистого листа</em>, и нет никаких ссылочных полей: инвариантов достаточно. Об этом гораздо легче рассуждать, и этот код проще для чтения. Не существует потери производительности: поскольку метод является хвостовой рекурсией, компилятор переводит его в обычный цикл.

<!--
elaborate..
-->


### Возвраты

Это не означает, что императивные структуры бесполезны.
Во многих случаях они хорошо подходят для прекращения вычислений вместо условных переходов для всех возможных вариантов окончания: ведь в приведенном выше `fixDown`, `return` используется для досрочного прекращения, если мы в конце кучи.

Возврат может быть использован, чтобы сократить количество ветвлений и установить инварианты. Он помогает читателю за счет уменьшения вложенности (как я сюда попал?) и делает легче рассуждения о правильности последующего кода (доступ к элементу массива не может происходить вне границ с этого места). Это особенно полезно в "guard" выражениях:

	def compare(a: AnyRef, b: AnyRef): Int = {
	  if (a eq b)
	    return 0
	
	  val d = System.identityHashCode(a) compare System.identityHashCode(b)
	  if (d != 0)
	    return d
	    
	  // slow path..
	}

Используйте `return` для уточнения и улучшения читаемости, но не так, как в императивных языках; избегайте его использования для возврата результатов вычислений. Вместо

	def suffix(i: Int) = {
	  if      (i == 1) return "st"
	  else if (i == 2) return "nd"
	  else if (i == 3) return "rd"
	  else             return "th"
	}

.LP лучше использовать:

	def suffix(i: Int) =
	  if      (i == 1) "st"
	  else if (i == 2) "nd"
	  else if (i == 3) "rd"
	  else             "th"

.LP но использование выражения <code>match</code> пододит лучше:

	def suffix(i: Int) = i match {
	  case 1 => "st"
	  case 2 => "nd"
	  case 3 => "rd"
	  case _ => "th"
	}

Обратите внимание, что использование `returns` тоже имеет свою цену: при использовании внутри замыкания,

	seq foreach { elem =>
	  if (elem.isLast)
	    return
	  
	  // process...
	}
	
.LP в байт-коде это реализовано в виде пары исключений catching/throwing, использование которых в реальном коде, влияет на производительность.

### Циклы `for` и включения

`for` обеспечивает краткий и натуральный способ для циклической обработки данных и их накопления. Это особенно полезно, когда обрабатывается много последовательностей.
Синтаксис `for` противоречит основному механизму выделения и управления замыканиями. Это может привести к непредвиденным расходам и двусмысленности, например

	for (item <- container) {
	  if (item != 2) return
	}

. LP может привести к ошибке выполнения, если произойдет задержка при вычислениеи container, что делает <code>return</code> не локальным!

По этим причинам, обычно предпочтительнее, вызвать `foreach`,
`flatMap`, `map` и `filter` напрямую - но использовать `for`, чтобы прояснить вычисления.

### `require` и `assert`

`require` и `assert`, оба оператора описаны в документации. Оба полезны для ситуаций, в которых система типов не может определить нужный вариант. `require`, используется для *invariants*, которые предполагаются в коде (или
внутреннем или внешнем), например

	val stream = getClass.getResourceAsStream("someclassdata")
	assert(stream != null)

В то время как `require` используется для представления API контрактов:

	def fib(n: Int) = {
	  require(n > 0)
	  ...
	}

## Функциональное программирование

*Программирование ориентированное на значение* дает много преимуществ, особенно когда используется в сочетании с конструкциями функционального программирования. Этот стиль
делает упор на преобразование значений вместо изменения состояния, возвращая код, который более прозрачен, обеспечивая больше инвариантов, а значит и легче в рассуждениях. Case классы, сопоставление с образцом, бессвязность, вывод типов, и легковесное замыкание - и метод - образуют синтаксис, который является предметов обсуждений.

### Case классы как алгебраический тип данных

Case классы представляют собой АТД(алгебраический тип данных): они полезны для моделирования большого числа
структур данных и обеспечивают более короткий код с сильными
инвариантами, особенно при использовании сопоставления с образцом. Сопоставление с образцом реализует исчерпывающий анализ, обеспечивая равномерные статические гарантии.

Используйте следующий образец при использовании АТД с Case классами:

	sealed trait Tree[T]
	case class Node[T](left: Tree[T], right: Tree[T]) extends Tree[T]
	case class Leaf[T](value: T) extends Tree[T]

.LP  тип <code>Tree[T]</code>имеет два конструктора: <code>Node</code> и <code>Leaf</code>. Объявление типа <code>sealed</code> позволяет компилятору сделать исчерпывающий анализ, поскольку конструкторы не могут быть добавлены за пределами исходного файла.

Вместе с использованием сопоставленя с образцом, мы получаем краткие и "очевидно правильные" результаты моделирования в коде:

	def findMin[T <: Ordered[T]](tree: Tree[T]) = tree match {
	  case Node(left, right) => Seq(findMin(left), findMin(right)).min
	  case Leaf(value) => value
	}

В то время как рекурсивные структуры, такие как деревья представляют собой классические реализации АТД, областей их полезного применения намного больше. Несвязные объединения, в частности, легко моделируется с помощью абстрактных типов данных; они часто встречаются в состояниях машины.

### Опции

Тип `Option` - это контейнер, который либо пуст (`None`), либо полон (`Some(value)`). Он обеспечивает безопасную альтернативу использованию `null`, и должен быть использован вместо null всякий раз, когда это возможно. Эти типы являются коллекциями (содержащими не более одного элемента) и они используют методы коллекций - используйте их!

Пишите

	var username: Option[String] = None
	...
	username = Some("foobar")

.LP вместо

	var username: String = null
	...
	username = "foobar"

.LP первый вариант безопаснее: тип <code>Option</code> статически проверяет что <code>Username</code> должен быть проверен на пустоту.

Условное выполнение `Option` значений должно быть сделано с
 помощью `foreach`, вместо

	if (opt.isDefined)
	  operate(opt.get)

.LP пишите

	opt foreach { value =>
	  operate(value)}

Стиль может показаться странным, но обеспечивает большую безопасность (мы не вызываем исключительно `get`) и краткость. Если есть два варианта выполнения, то при использовании сопоставлении с образцом:

	opt match {
	  case Some(value) => operate(value)
	  case None => defaultAction()
	}

.LP но если все варианты ложные, то для значения по умолчанию, используйте <code>getOrElse</code>

	operate(opt getOrElse defaultValue)

Не злоупотребляйте `Option`: если имеется значение по 
умолчанию - [*Null Object*](http://en.wikipedia.org/wiki/Null_Object_pattern) - используйте его.

`Option` также предоставляет удобный конструктор для упаковки nullable значения:

	Option(getClass.getResourceAsStream("foo"))

.LP является <code>Option[InputStream]</code> которая может  принимать значение <code>None</code>, в этом случае <code>getResourceAsStream</code> должен возвратить <code>null</code>.

### Сопоставление с образцом

Сопоставление с образцом (`x match { ...`) широко распространено в хорошо написанном Scala коде: оно осуществляет условное выполнение, разбор конструкций, и все это в одной конструкции. При его использовании также повышается четкость и безопасность.

Используйте сопоставление с образцом для реализации переключения типов:

	obj match {
	  case str: String => ...
	  case addr: SocketAddress => ...
 
Сопоставление с образцом лучше всего работает в сочетании с разбором конструкций (например, работе с Case классами), вместо

	animal match {
	  case dog: Dog => "dog (%s)".format(dog.breed)
	  case _ => animal.species
	  }

.LP лучше написать

	animal match {
	  case Dog(breed) => "dog (%s)".format(breed)
	  case other => other.species
	}


Используйте [custom extractors](http://www.scala-lang.org/node/112), но только с дополнительным конструктором (`apply`), в противном случае их использования может быть неуместным.

Не используйте сопоставление с образцом для вычисления условий, когда имеет смысл использовать стандартные значения. Библиотеки коллекций  обычно предоставляет методы, которые возвращают `Option`; избегайте

	val x = list match {
	  case head :: _ => head
	  case Nil => default
	}

.LP потому что

	val x = list.headOption getOrElse default

.LP так короче и болешь соответствует цели

### Частичные функции

Scala предоставляет синтаксический сахар для определения `PartialFunction`:

	val pf: PartialFunction[Int, String] = {
	  case i if i%2 == 0 => "even"
	}

.LP и они могут использоваться вместе с <code>orElse</code>

	val tf: (Int => String) = pf orElse { case _ => "odd"}

	tf(1) == "odd"
	tf(2) == "even"

Частичные функции исопльзуются во многих ситуациях и эффективно
кодируются с помощью `PartialFunction`, например, в качестве аргументов
методов

	trait Publisher[T] {
	  def subscribe(f: PartialFunction[T, Unit])
	}

	val publisher: Publisher[Int] = ..
	publisher.subscribe {
	  case i if isPrime(i) => println("found prime", i)
	  case i if i%2 == 0 => count += 2
	  /* ignore the rest */
	}

.LP или в ситуациях, которые могли бы способствовать возврату <code>Option</code>

	// Attempt to classify the the throwable for logging.
	type Classifier = Throwable => Option[java.util.logging.Level]

.LP может быть лучше выражено с помощью <code>PartialFunction</code>

	type Classifier = PartialFunction[Throwable, java.util.Logging.Level]

.LP так как это более компактно:

	val classifier1: Classifier
	val classifier2: Classifier

	val classifier = classifier1 orElse classifier2 orElse { _ => java.util.Logging.Level.FINEST }


### Ликвидация привязок (Destructuring bindings)

Ликвидация привязок тесно связана с сопоставлением с образцом; используется тот же механизм, но применяется, когда есть только один вариант (чтобы не сгенерировать исключение). Ликвидация привязок особенна полезны для кортежей и Case классов.

	val tuple = ('a', 1)
	val (char, digit) = tuple

	val tweet = Tweet("just tweeting", Time.now)
	val Tweet(text, timestamp) = tweet

### Ленивые вычисления

Поля в Scala вычисляется *по необходимости*, когда `val` имеет префикс
 `lazy`. Поэтому поля и методы в Scala эквиваленты (поля как бы `private[this]`)

	lazy val field = computation()

.LP это примерное сокращение для

	var _theField = None
	def field = if (_theField.isDefined) _theField.get else {
	  _theField = Some(computation())
	  _theField.get
	}

.LP то есть, результаты вычисляются и запоминаются. Используйте ленивые поля для этого, но избегайте использования ленивых вычислений, когда ленивые вычисления требуются по смыслу. В этих случаях лучше производить вычисления явно, поскольку можно точно произвести оценку, и побочные эффекты могут контролироваться более точно.

Ленивые поля являются потокобезопасными.

### Передача по имени

Параметры методов могут быть переданы по имени, то есть параметр принимает не значение, а *вычисление*, которое может повторяться. Это
функция должна применяться с осторожностью; вызывающая функция может ожидать передачу по значению, но в ответ будет удивлена. Способ применения этой особенности - это построение обычных синтаксических DSL - например, могут быть сделаны новые конструкции управления, чтобы выглядеть так же, как и родные особенности языка.

Используйте передачу по имени управляющих конструкций, когда для вызывающей функции очевидно, что передается в это "блок", а не
результат каких-то неожиданных вычислений. Используйте передачу по имени в крайней позиции последнего списка аргументов. При использовании передачи по имени, убедитесь, что метод назван очевидным образом для вызывающей функуции, которая передает аргумент.

Если вы хотите, чтобы значения вычислялись несколько раз, и, особенно, когда вычисление имеет побочные эффекты, используйте явные функции:


	class SSLConnector(mkEngine: () => SSLEngine)

.LP ваше намерение остается очевидным и для вызывающей функции это не будет сюрпризом

### `flatMap`


[Scala]: http://www.scala-lang.org/
[Finagle]: http://github.com/twitter/finagle
[Util]: http://github.com/twitter/util
