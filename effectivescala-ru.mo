<a href="http://github.com/twitter/effectivescala"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

<h1 class="header">Effective Scala</h1>
<address>Marius Eriksen, Twitter Inc.<br />marius@twitter.com (<a href="http://twitter.com/marius">@marius</a>)<br /><br />[translated by Eugene Sysmanov(<a href="https://github.com/appigram">@appigram</a>)]</address>

<h2>Table of Contents</h2>

.TOC


<h2>Другие языки</h2>
<a href="index.html">English</a>
<a href="index-ja.html">日本語</a>

## Введение

[Scala][Scala] является одним из основных языков программирования, который испоьзуется в Twitter. Большая часть нашей инфрастуктуры написана на Scala и [у нас есть несколько крупных библиотек](http://github.com/twitter/) поддерживается нами.

Scala не только очень эффективный, но также и большой язык, полученный нами опыт, научил нас быть очень осторожным при его использовании на практике в своем приложении. Где скрыты подводные камни? Какие особенности стоит использвать, а от каких отказаться? Когда мы можем использовать «чисто функциональный стиль», а когда его следует избегать? Другими словами: что мы используем, чтобы быть более эффективными при использовании языка? Это руководство пытается передать наш опыт в коротких заметках, представляя набор *лучших практик*. Мы используем Scala для создания высококачественных услуг, которые представляют собой распределенные системы - наше мнение возможно будет предвзято - но большинство советов здесь должны работать без проблем и 
при переносе на другие системы. Все это не истина в последней инстанции, и отклонение должно быть вполне приемлимым.


Scala предоставляет множество инструментов, которые позволяют кратко описывать свои действия. Если мы меньше будем набирать символов, значит меньше придется читать, а значит исходный код будет прочитан быстрее, из этого следует, что краткость повышает ясность. Однако краткость может быть и тупым инструментом, который может оказать обратный эффект: вслед за правильностью, всегда нужно думать о читателе.

Немного, о *программе на Scala*. Вы не пишете код ни на Java, ни на Haskell, ни на Python; написание Scala-программы отличается от написания в любом из этих языков. Для того чтобы использовать язык эффективно, вы должны описать свои проблемы, в терминах этого языка. Вас никто не принуждает использовать программу, написанную на Java, в Scala, в большинстве случаев она будет уступать оригиналу.

Данный документ не введение в язык Scala, мы предполагаем, что читатель
знаком с языком. Вот некоторые ресурсы для обучения языку Scala:

* [Scala School](http://twitter.github.com/scala_school/)
* [Learning Scala](http://www.scala-lang.org/node/1305)
* [Learning Scala in Small Bites](http://matt.might.net/articles/learning-scala-in-small-bites/)

Данные статьи - это живой документ, который будет меняться с учетом наших текущих "лучших практик", но его основные идеи вряд ли изменятся: писать код, который всегда легко читаем; писать универсальный код, но не в ущерб
ясности; пользоваться простыми функциями языка, которые обладают большой
мощью, но избегать эзотерических функций (особенно в системе типов).
Прежде всего, всегда нужно находить компромиссы в том, что вы делаете.Сложность языка требуется в комплексных реализациях, потому что она порождает сложность: в рассуждениях, в семантике, во взаимодействия между особенностями системы, а также в понимании между вашими сотрудниками. Таким образом, трудность является производной сложности - вы всегда должны убедиться, что ее полезность превышает ее стоимость.

И получайте удовольствие.

## Форматирование

Специфические способы *форматирования кода* - пока они практичны -
не имеют большого значения. По определению, стиль не может быть хорошим или плохим, почти все определяет личное предпочтение. Однако, *последовательное* применение одних и тех же правил форматирования будет почти всегда увеличивать удобочитаемость. Читатель, уже знакомый с данным стилем, не должен разбираться в еще одном наборе местных соглашений или расшифровать еще одну часть языковой грамматики.

Это имеет особое значение для Scala, поскольку у его грамматики высокий уровень вхождения. Один говорящий пример - вызов метода: Методы
может быть вызваны с помощью "`.`", либо с использованием пробела, либо без круглой скобки для не возвращающих значений или унарных методов, с круглой скобкой для них, и так далее. Кроме того, различные стили вызова метода оставляют двусмысленность в его грамматике! Конечно, последовательное применение тщательно выбранного набора правил форматирования решит большую часть двусмысленности и для человека и для машины.

Мы придерживаемся [Правила форматирования в языке Scala] (http://docs.scala-lang.org/style/) и дополнительно следующих правил.

### Пробельные символы

При отступе используется 2 пробельных символа. Мы стараемся избегать строк, длиной более 100 символов. Мы используем одну пустую строку между методом, классом и определениями объекта.

### Именование

<dl class="rules">
<dt>Используйте короткие имена для небольших областей видимости</dt>
<dd>Применяйте <code>i</code>,<code>j</code> и <code>k</code> и подобне переменные в циклах </dd>
<dt>Используйте длинные имена для больших областей видимости</dt>
<dd>Внешние API должны иметь длинные и понятные имена, которые придают смысл.
<code>Future.collect</code> вместо <code>Future.all</code>.
</dd>
<dt>Используйте стандартные сокращения, и откажитесь от эзотерических</dt>
<dd>
Всем известны <code>ok</code>, <code>err</code> или <code>defn</code>,а вот <code>sfri</code> используется не так часто.
</dd>
<dt>Не используйте одни и теже имена для различных целей</dt>
<dd>Применяйте <code>val</code></dd>
<dt>Избегайте использования <code>`</code> для перегрузки зарезервированных имен.</dt>
<dd>Используйте <code>typ</code> вместо <code>`type</code>`</dd>
<dt>Используйте имени active для операций с побочными эффектами</dt>
<dd><code>user.activate()</code> вместо <code>user.setActive()</code></dd>
<dt>Используйте описательные имен для методов, которые возвращают значения</dt>
<dd><code>src.isDefined</code> вместо <code>src.defined</code></dd>
<dt>Не используйте у геттеров(getter) префикс <code>get</code></dt>
<dd>В соответствии с предыдущим правилом: лучше применять <code>site.count</code> вместо <code>site.getCount</code></dd>
<dt>Не используйте повторно имена, которые уже есть в пакете или в названии объекта</dt>
<dd>Предпочтительно:
<pre><code> object User {
   def get(id: Int): Option[User]
}</code></pre>вместо
<pre><code>object User {
   def getUser(id: Int): Option[User]
}</code></pre>Они являются избыточными при использовании: <code>User.getUser</code> дает не больше информации, чем <code>User.get</code>.
</dd>
</dl>

### Импортирование

<dl class="rules">
<dt>Располагайте строки импорта в алфавитном порядке</dt>
<dd>Так их проще определить визуально, и так проще для автоматизации.</dd>
<dt>Используйте фигурные скобки при импортировании нескольких имен из пакета</dt>
<dd><code>import com.twitter.concurrent.{Broker, Offer}</code></dd>
<dt>Используйте символ подчеркивания, когда импортируйте более 6 имен</dt>
<dd>например: <code>import com.twitter.concurrent._</code>
<br />Не применяйте его без оглядки, некоторые пакеты экспортируют слишком много имен</dd>
<dt>Когда используете коллекции, уточняйте имена при импортировании <code>scala.collection.immutable</code> и/или <code>scala.collection.mutable</code></dt>
<dd>Изменяемые и неизменяемые коллекции имеют двойные имена. Уточнение имен сделает очевидным для читателя какой вариант используется (например "<code>immutable.Map</code>")</dd>
<dt>Не используйте относительный импорт из других пакетов</dt>
<dd>Избегайте <pre><code>import com.twitter
import concurrent</code></pre> в пользу более одназначного <pre><code>import com.twitter.concurrent</code></pre></dd>
<dt>Располагайте строки импорта вверху файла</dt>
<dd>Читатель может обратится ко всем строкам импорта в одном месте</dd>
</dl>

### Фигурные скобки

Фигурные скобки используются для создания сложных выражений (они служат другим целям в "языковом модуле"), где значение соответствующего выражения является последним выражением в списке. Старайтесь не использовать скобки для простых выражений; пишите

	def square(х: Int) = х*х

.LP, вместо

	def square(х: Int) = {
 	  х * х
	}

.LP, хотя это может быть привлекательным, чтобы отличить тело метода синтаксически. Первый вариант имеет меньший беспорядок и его легче читать. <em>Избегайте синтаксических церемоний</em>, если это не уточняется.

### Сравнение с образцом

Используйте сравнение с образцом в определении функций, когда это необходимо;
Вместо

	list map { item =>
	  item match {
	    case Some(x) => x
	    case None => default
	  }
	}

.LP лучше написать так

	list map {
	  case Some(x) => x
	  case None => default
	}

.LP ясно, что элементы списка в настоящее время отображаются более ясно &mdash; дополнительно уточнять ничего не нужно.

### Комментарии

Используйте [ScalaDoc](https://wiki.scala-lang.org/display/SW/Scaladoc), чтобы предоставлять документацию по API, Используйте следующий стиль:

	/**
	 * ServiceBuilder builds services 
	 * ...
	 */
	 
.LP <em>вместо</em>стандартного стиля ScalaDoc:

	/** ServiceBuilder builds services
	 * ...
	 */

Не прибегайте к ASCII искусству или другим визуальным украшениям. Документируйте API, но не добавляйте ненужных комментариев. Если вы добавляете комментарии, чтобы объяснить поведение вашего кода, сначала спросите себя, может ли код быть переписан так, чтобы стало очевидным, что он делает. Предпочитайте "Очевидно, это работает" вместо "Это работает, очевидно" (цитата Энтони Хоара).

(прим. переводчика: "Есть два метода создания программного обеспечения. Один из них — сделать программу настолько простой, что, очевидно, в ней нет недостатков. И другой, сделать приложение настолько сложным, что в нем невидно явных недостатков." - [Энтони Хоар](http://ru.wikipedia.org/wiki/Хоар,_Чарльз_Энтони_Ричард) выдержка из лекции, [Премия Тьюринга](http://amturing.acm.org/award_winners/hoare_4622167.cfm))

## Типы и обобщенные типы

Основной целью системы типов является выявление ошибок программирования. Система типов эффективно обеспечивает определенную форму статической проверки, что позволяет нам получать определенный набор неизменных параметров о нашем коде, который компилятор может проверить. Система типов конечно обеспечивает и другие преимущества, но проверка ошибок является ее основной целью.

Наше использование системы типов должно отражать эту цель, но мы должны не забывать и о читателе: разумное использование типов может служить повышением ясности, быть заумным только запутывать остальных.

Мощная система типов в Scala является результатом общих усилий академических опытов и разработок (например, [Scala программирование на уровне системы типов] (http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/)).
В то время как это увлекательная академическая статья, эти методы редко находят полезное применение в реальном коде приложений. Их можно избегать.

### Возвращаемый тип аннотаций

В то время как Scala позволяет опускать их, такие аннотации обеспечивают хорошую документацию: это особенно важно для публичных методов. Там где возвращаемый тип метода очевиден, их можно опустить.

Это особенно важно при создании экземпляров объектов с миксинами(Mixins), так как компилятор Scala создает тип синглтон(singleton) для них. Например, `make` в примере:

	trait Service
	def make() = new Service {
	  def getId = 123
	}

.LP <em>не</em> имеет возвращаемого типа <code>Service</code>, компилятор создает <code>Object with Service{def getId: Int}</code>. Вместо того, чтобы использовать явную аннотацию:

	def make(): Service = new Service{}

В настоящее время автор свободен смешивать множество трейтов(traits) без изменения общедоступного типа `make`, делая возможность легче управлять обратной совместимостью.

### Противоречие

Противоречие возникает, когда обобщеные типы объединены с выделением подтипов. Они определяют как выделение подтипов типа *contained* относится к выделению подтипов типа *container*. Потому что Scala имеется определенное соглашение по комментированию, авторы общих библиотек - особенно коллекций -
должны быть активными комментаторами. Такие комментарии важны для
удобства работы с общим кодом, но неверные комментарии могут быть опасны.

Инварианты - усовершенствованный, но необходимый компонент системы типов Scala,и должны использоваться широко (и правильно), поскольку это помогает приложению в выделении подтипов.

*Коллекции Immutable должны быть зависимыми(covariant)*. Методы, которые получают
contained тип должны быть "понижены"("downgrade") до соответствующей коллекции:
	
	trait Collection[+T] {
	  def add[U >: T](other: U): Collection[U]
	}

*Mutable коллекции должны быть неизменяемы(invariant)*. Зависимость обычно бессмыслена с изменяемыми(mutable) коллекциями. Будем считать

	trait HashSet[+T] {
	  def add[U >: T](item: U)
	}

.LP и следующую иерархию типов:

	trait Mammal
	trait Dog extends Mammal
	trait Cat extends Mammal

.LP Если у меня сейчас есть хеш-коллекцию из объектов Собака

	val dogs: HashSet[Dog]

.LP создаем хеш-коллекцию Млекопитающих и добавляем в колллекцию объект Кошка

	val mammals: HashSet[Mammal] = dogs
	mammals.add(new Cat{})

.LP Теперь эта хеш-коллекция не является коллекцией объектов Собака！

(прим. переводчика: Поддробнее о [ковариантности и контрвариантности](http://chabster.blogspot.com/2008/01/type-system-covariance-and.html))

<!--
  *	when to use abstract type members?
  *	show contravariance trick?
-->

### Псевдонимы типов

Используйте псевдонимы типов, когда они позволяют удобное именование или разъяснение цели, но не искажают типы, которые очевидны.

	() => Int

.LP данная запись более понятна чем

	type IntMaker = () => Int
	IntMaker

.LP так как это короче и используется общий тип, однако

	class ConcurrentPool[K, V] {
	  type Queue = ConcurrentLinkedQueue[V]
	  type Map   = ConcurrentHashMap[K, Queue]
	  ...
	}

.LP более полезно, так как это передает цель и улучшает краткость.

Не используйте разделение на подклассы, когда псевдоним делает тоже самое

	trait SocketFactory extends (SocketAddress => Socket)
	
.LP <code>SocketFactory</code> <em>это</em> функция которая создает <code>Socket</code>. Использование псевдонима

	type SocketFactory = SocketAddress => Socket

.LP более правильно. Теперь мы можем обеспечить функциональные идентификаторы для значений типа<code>SocketFactory</code>,а также использовать композицию функций:

	val addrToInet: SocketAddress => Long
	val inetToSocket: Long => Socket

	val factory: SocketFactory = addrToInet andThen inetToSocket

Псевдонимы типа связаны с именами, которые стоят выше в иерархии при помощи пакетных объектов:

	package com.twitter
	package object net {
	  type SocketFactory = (SocketAddress) => Socket
	}

Обратите внимание на то, что псевдонимы, это не новые типы - они эквивалентны
синтаксической замене типа новым именем.

### Неявные преобразования

Неявные преобразования являются мощной возможностью системы типов, но они должны использоваться экономно. Они усложняют правила преобразования и делают это достаточно трудно -- простым лексическим сравнением -- чтобы понять, что на самом деле происходит. Обычно неявные преобразования используются в следуюей ситуации:

* Расширение или добавление коллекций стиля программирования Scala
* Адаптация или расширение объекта (шаблон "pimp my library")
* Использование для *повышения безопасности типов*, предоставляя ограниченный набор данных
* Чтобы представить данные типа (typeclassing)
* Для `Манифестов`

Если действительно хотите использовать неявные преобразования, всегда спрашивайте себя, есть ли способ достигнуть той же цели без их помощи.

Не используйте неявные преобразования, чтобы сделать автоматическое преобразование между похожими типами данных (например, преобразование списка в поток); это лучше сделать явно, потому что у типов есть различная семантика, и читатель должен остерегаться подобных реализаций.

## Коллекции

У Scala есть универсальная, очень богатая, мощная, и прекрасно составленная библиотека коллекций; коллекции - высокоуровневые реализации и они представляют собой большой набор различный операций. Много действий с коллекциями и их преобразования могут быть выражены кратко и четко, но небрежное применение функций может привести к противоположному результату. Каждый Scala-программист должен прочитать [Сollections design document](http://www.scala-lang.org/docu/files/collections-api/collections.html);
он обеспечит большее понимание при работе с библиотекой коллекций Scala.

Всегда используйте самую простую коллекцию, которая соответствует вашим потребностям отребностям.

### Иерархия

Библиотека коллекций очень большая: в дополнение к сложной
иерархии - корнем которой является `Traversable[T]` - существуют
`immutable` и `mutable` варианты для большинства коллекций. Несмотря на сложность, на следующей диаграмме содержится важная
различия между `immutable` и `mutable` иерархиями

<img src="coll.png" style="margin-left: 3em;" />
.cmd
pic2graph -format png >coll.png <<EOF 
boxwid=1.0

.ft I
.ps +9

Iterable: [
	Box: box wid 1.5*boxwid
	"\s+2Iterable[T]\s-2" at Box
]

Seq: box "Seq[T]" with .n at Iterable.s + (-1.5, -0.5)
Set: box "Set[T]" with .n at Iterable.s + (0, -0.5)
Map: box "Map[T]" with .n at Iterable.s + (1.5, -0.5)

arrow from Iterable.s to Seq.ne
arrow from Iterable.s to Set.n
arrow from Iterable.s to Map.nw
EOF
.endcmd

.LP <code>Iterable[T]</code> - это любая коллекция, элементы которой могут быть итерированы, она имеет метод <code>iterator</code>(а также <code>foreach</code>).<code>Seq[T]</code>- это коллекция, элементы которой <em>отсортированы</em>,<code>Set[T]</code>- является аналогом математического множества (неупорядоченная коллекция уникальных элементов), и <code>Map[T]</code> - который представляет собой неотсортированный ассоциативный массив.

### Применение

* Предпочитительнее использовать immutable коллекции.* Они применимы в большинстве случаев, и делают программу проще и прозрачнее в понимании,а также потокобезопасной по умолчанию.

* Используйте `mutable` пространство имен явно.* Не импортируйте
`scala.collection.mutable._` и ссылку на `set`, лучше сделать так

	import scala.collections.mutable
	val set = mutable.Set()

.LP потому что становится чсно, что используется mutable вариант

* Используйте стандартный конструктор для коллекций.* Всякий раз, когда вам нужна упорядоченная последовательность (и не обязательно связаный список), используйте конструктор `Seq()`, и тому подобное:

	val seq = Seq(1, 2, 3)
	val set = Set(1, 2, 3)
	val map = Map(1 -> "one", 2 -> "two", 3 -> "three")

.LP Этот стиль отделяет семантику коллекции от ее реализации, позволяя библиотеке коллекций использовать наиболее подходящий тип: если вам нужна <code>Map</code>, не обязательно использовать <a href="http://ru.wikipedia.org/wiki/Красно-чёрное_дерево">Красно-черное дерево(Red-Black Tree)</a>. Кроме того, стандартные конструкторы будут часто использовать специализированные представления: например, <code>Map()</code> будет использовать объект с 3 полями для карт с 3 ключами(<a href="http://www.scala-lang.org/api/current/scala/collection/immutable/Map$$Map3.html"><code>Map3</code></a>).

В заключение к сказанному выше: в ваших собственных методах и конструкторах *старайтесь использовать самую универсальную коллекцию*. Обычно это сводится к одной из приведенных: `Iterable`, `Seq`, `Set`, или `Map`. Если ваш метод нуждается в последовательности, используйте `Seq[T]`, а не `List [T]`.

<!--
something about buffers for construction?
anything about streams?
-->

### Стиль

Функциональное программирование призывает к цепочечным преобразованиям
immutable коллекций для получения желаемого результата. Это часто
приводит к очень коротким решениям, но также может ввести в заблуждение
читателя - часто трудно понять намерения автора, или отслеживать все промежуточные результаты, которые подразумеваются. Например,
предположим, что мы хотим собрать голоса для разных языков программирования
из набора (язык, число голосов), показывая их, в порядке убывания числа голосов, мы могли бы написать:

	val votes = Seq(("scala", 1), ("java", 4), ("scala", 10), ("scala", 1), ("python", 10))
	val orderedVotes = votes
	  .groupBy(_._1)
	  .map { case (which, counts) => 
	    (which, counts.foldLeft(0)(_ + _._2))
	  }.toSeq
	  .sortBy(_._2)
	  .reverse

.LP это кратко и правильно, но почти любому читателю нужно время, чтобы восстановить в голове первоначальные намерения автора. Стратегия, которая призвана уточнить решение <em>использование промежуточных результатов и параметров</em>:

	val votesByLang = votes groupBy { case (lang, _) => lang }
	val sumByLang = votesByLang map { case (lang, counts) =>
	  val countsOnly = counts map { case (_, count) => count }
	  (lang, countsOnly.sum)
	}
	val orderedVotes = sumByLang.toSeq
	  .sortBy { case (_, count) => count }
	  .reverse

.LP код является почти столь же кратким, но гораздо более четко описывает происходящие превращения (именованные промежуточные значения), и структуры данных с которыми работает программа (именованные параметры). Если вы беспокоитесь о засорении пространства имен, применяя этот стиль, используйте группировку выражений с помощью <code>{}</code>:

	val orderedVotes = {
	  val votesByLang = ...
	  ...
	}


### Производительность

Высокоуровневые библиотеки коллекций (как обычно и с высокоуровневыми конструкциями), делают определение производительности более трудоемким:
чем дальше вы отклоняетесь от указания непосредственных команд компьютеру - другими словами, императивного стиля - тем тяжелее предсказать точное значение производительности участка кода. Обосновать правильность, однако, обычно проще; удобочитаемость также улучшается. Со Scala ситуация осложнена средой исполнения Java; Scala скрывает операции упаковки/распаковки от нас, но они могут серьезно влиять на производительность или оказывать негативное воздействие.

Прежде, чем сфокусироваться на низкоуровневых деталях, удостоверьтесь, что используете коллекцию, подходящую в данном случае. Удостоверьтесь, что ваша структура данных не имеет неожиданной асимптотической сложности. Сложности для разных Scala коллекций описаны [здесь](http://www.scala-lang.org/docu/files/collections-api/collections_40.html).

Первое правило оптимизации производительности состоит в том, чтобы понять *почему* ваше приложение медленно работает. Не стоит действовать без оглядки; профилируйте^ [Yourkit] (http://yourkit.com) - неплохой профилировщик] приложение до начала дальнейших действий. Фокусируйтесь сначала на интенсивно используемых циклах и больших структурах данных. Чрезмерные усилия на оптимизацию обычно тратятся впустую. Помните принцип Кнута: "Преждевременная оптимизация - корень все зол."

Очень часто целесообразно использовать низкоуровневые коллекции в ситуациях где требуется лучшая производительность или иметь задел эффективности на будущее. Используйте массивы вместо списков для больших последовательностей (неизменяемая `Vector` коллекция обеспечивает похожий прозрачный интерфейс для массивов); и используйте буферы вместо конструирования последовательности, когда стоят вопросы производительности.

### Java Коллекции

Используйте `scala.collection.JavaConverters` для взаимодействия с коллекциями Java. Эта коллекция неявно добавляет методы преобразования `asJava` и `asScala`. Их использование гарантирует, что такие преобразования являются явными, помогая
читателю:

	import scala.collection.JavaConverters._
	
	val list: java.util.List[Int] = Seq(1,2,3,4).asJava
	val buffer: scala.collection.mutable.Buffer[Int] = list.asScala

## Параллелизм

Современные сервисы обладают высоким уровнем параллелизма - все серверы выполняют 10-100 тысяч одновременных операций - и их обработка подразумевают сложность, которая является центральной темой в надежных программных системах.

*Потоки* являются средством выражения параллелизма: они дают вам независимые контексты выполнения с общей разделяемой памятью, которые управляются операционной системой. Тем не менее, создание потоков является затратной операцией в Java и этим ресурсом необходимо управлять, как правило, с использованием пулов. Это создает дополнительные сложности для программиста, а также обладает высокой степенью связности: трудно отделить логику приложения от используемых им основных ресурсов.

Эта сложность особенно заметна при создании сервисов, которые
имеют высокую степень параллелизма: каждый приходящий результат запроса в множество всех запросов на каждый уровень системы. В таких системах, пулы потоков должны быть организованы таким образом, чтобы они быди сбалансированы
в зависимости от количества запросов на каждом уровне: беспорядок в одном пуле потоков негативно влияет на другие.

Надежная система должна также не упускать из виду тайм-ауты и отмены, оба этих элемента требуют введения дополнительного  «контроля» потоков, тем самым усложняя проблему еще больше. Заметим, что если бы потоки были более дешевыми, то эти проблемы бы уменьшились: нет необходимости в пулах, тайм-аут потоков мог бы быть отброшен, и никаких дополнительных ресурсов
для управления не потребовалось бы.

Таким образом, управление ресурсами ставит под угрозу модульность.

### Futures

Используйте futures(актор с возможностью блокировки создающего его потока, если создающий поток запросил результат вычисления - прим. переводчика) для управления параллелизмом. Они позволяют отделить параллельные операции от управления ресурсами: например, [Finagle][Finagle] объединяет параллельные операции в несколько потоков эффективным
образом. Scala имеет легковесный синтаксис замыканий, поэтому futures вводят немного синтаксического сахара, и они становятся более популярны среди программистов.

Futures позволяют программисту выразить параллельные вычисления в декларативном стиле, скомпоновать, и управлять источником ошибки. Эти качества убедили нас в том, что они особенно хорошо подходят для использования в функциональных языках программирования, где подобный стиль поощряется.

*Изменяйте futures вместо создания собственных.* Future
преобразования позволяют поймать ошибку, определить сигнал об отмене, и освобождает программиста от мысли, о релизации модели памяти в Java. Даже осторожный программист может написать следующую выдачу RPC последовательности из 10 элементов, а затем напечатать результаты:

	val p = new Promise[List[Result]]
	var results: List[Result] = Nil
	def collect() {
	  doRpc() onSuccess { result =>
	    results = result :: results
	    if (results.length < 10)
	      collect()
	    else
	      p.setValue(results)
	  } onFailure { t =>
	    p.setException(t)
	  }
	}

	collect()
	p onSuccess { results =>
	  printf("Got results %s\n", results.mkString(", "))
	}

Программист должен убедиться, что ошибки RPC распространяются,
смешивая код и контроль потока выполнения; хуже того, этот код неверен! Без объявления переменной `results`, мы не можем гарантировать, что `results` содержит предыдущее значение на каждой итерации. Модель памяти Java не так проста, но, к счастью, мы можем избежать всех этих ошибок с помощью
декларативного стиль:

	def collect(results: List[Result] = Nil): Future[List[Result]] =
	  doRpc() flatMap { result =>
	    if (results.length < 9)
	      collect(result :: results)
	    else
	      result :: results
	  }

	collect() onSuccess { results =>
	  printf("Got results %s\n", results.mkString(", "))
	}

Мы используем `flatMap` в последовательности операций и сохраняем результат в список, пока мы производим вычисления. Это общая идея функциональных языков программирования
реализована в Futures. Для этого требуется меньше шаблонов, появляется меньше ошибок, а также читается лучше.

*Используйте Futures комбинаторы*. `Future.select`, `Future.join`, и `Future.collect` реализуют общие шаблоны при работе над несколькими Futures, которые должны быть объединены.

### Коллекции

С параллельными коллекциями связано множество мнений,
тонкостей, догм, страха, неуверенности и сомнения. В большинстве практических ситуаций, они не являются проблемой: Всегда начинайте с самой простой, самой скучной, и в основном
стандартной коллекции, которая служит поставленной цели. Не прикасайтесь к параллельной коллекции до того как вы *знаете*, что синхронизированный вариант коллекции не работает: JVM имеет современные механизмы, чтобы сделать синхронизацию дешевой операцией, так что их эффективность может вас удивить.

Если необходимо использовать неизменяемую коллекцию, используйте - она совершенно прозрачна, поэтому рассуждать о них в контексте параллельных вычислений очень просто. Изменения в незменяемых коллекциях, как правило, выполняются путем обновления ссылки на текущее значение (в `var` ячейке или
`AtomicReference`). Необходимо соблюдать осторожность, чтобы применять это корректно: атомы должны быть повторно объявлены, и `переменные` должны быть объявлены на лету в порядке их объявления в других потоках.

Изменяемые параллельные коллекции имеют сложную семантику, и используют тонкости модели памяти в Java, поэтому убедитесь, что вы понимаете последствия - особенно по отношению к использованию обновлений - прежде чем начинать использовать их. Синхронные коллекции тоже лучший вариант: операции, такие как `getOrElseUpdate` не могут быть правильно реализованы для параллельных коллекций, и создание сложных коллекций особенно подвержено ошибкам.

<!--

use the stupid collections first, get fancy only when justified.

serialized? synchronized?

blah blah.

Async*?

-->


## Управляющие структуры

Программы в функциональном стиле, как правило, требуют меньше традиционных управляющих структур, и читать код лучше, когда он написан в декларативном стиле. Это обычно означает, разделение вашей логики на несколько небольших методов или функций, и склеивание их вместе с `match` выражениями. Функциональные программы также имеют тенденцию быть более
ориентированными на выражения: ветви условных выражений для значений того же типа, `for (..) yield` вычисления включений, и рекурсия являются обычным делом.

### Рекурсия

*Формулировка проблемы в терминах рекурсии обычно упрощает ее*, и если применяется оптимизация хвостовой рекурсии (которая может быть проверена с помощью аннотации `@tailrec`), компилятор преобразует ​​код в обычный цикл.

Рассмотрим довольно стандартную императивную реализацию кучи <span class = "algo">fix-down</span>:

	def fixDown(heap: Array[T], m: Int, n: Int): Unit = {
	  var k: Int = m
	  while (n >= 2*k) {
	    var j = 2*k
	    if (j < n && heap(j) < heap(j + 1))
	      j += 1
	    if (heap(k) >= heap(j))
	      return
	    else {
	      swap(heap, k, j)
	      k = j
	    }
	  }
	}

Каждый раз, при входе в цикл, мы работаем с состоянием предыдущей итерации. Значением каждой переменной является результат вычисления функции определенной ветви выполнения, и он возвращается в середине цикла, если был найден верный результат вычисления (внимательный читатель найдет похожие
аргументы в Дейкстры ["О вреде оператора Go To"](http://www.vspu.ac.ru/~chul/dijkstra/goto/goto.htm)).

Рассмотрим реализацию (хвостовой) рекурсии^[Из [Finagle's heap balancer](https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/loadbalancer/Heap.scala#L41)]:

	@tailrec
	final def fixDown(heap: Array[T], i: Int, j: Int) {
	  if (j < i*2) return
	
	  val m = if (j == i*2 || heap(2*i) < heap(2*i+1)) 2*i else 2*i + 1
	  if (heap(m) < heap(i)) {
	    swap(heap, i, m)
	    fixDown(heap, m, j)
	  }
	}

.LP здесь каждая итерация начинается с <em>чистого листа</em>, и нет никаких ссылочных полей: инвариантов достаточно. Об этом гораздо легче рассуждать, и этот код проще для чтения. Не существует потери производительности: поскольку метод является хвостовой рекурсией, компилятор переводит его в обычный цикл.

<!--
elaborate..
-->


### Возвраты

Это не означает, что императивные структуры бесполезны.
Во многих случаях они хорошо подходят для прекращения вычислений вместо условных переходов для всех возможных вариантов окончания: ведь в приведенном выше `fixDown`, `return` используется для досрочного прекращения, если мы в конце кучи.

Возврат может быть использован, чтобы сократить количество ветвлений и установить инварианты. Он помогает читателю за счет уменьшения вложенности (как я сюда попал?) и делает легче рассуждения о правильности последующего кода (доступ к элементу массива не может происходить вне границ с этого места). Это особенно полезно в "guard" выражениях:

	def compare(a: AnyRef, b: AnyRef): Int = {
	  if (a eq b)
	    return 0
	
	  val d = System.identityHashCode(a) compare System.identityHashCode(b)
	  if (d != 0)
	    return d
	    
	  // slow path..
	}

Используйте `return` для уточнения и улучшения читаемости, но не так, как в императивных языках; избегайте его использования для возврата результатов вычислений. Вместо

	def suffix(i: Int) = {
	  if      (i == 1) return "st"
	  else if (i == 2) return "nd"
	  else if (i == 3) return "rd"
	  else             return "th"
	}

.LP лучше использовать:

	def suffix(i: Int) =
	  if      (i == 1) "st"
	  else if (i == 2) "nd"
	  else if (i == 3) "rd"
	  else             "th"

.LP но использование выражения <code>match</code> пододит лучше:

	def suffix(i: Int) = i match {
	  case 1 => "st"
	  case 2 => "nd"
	  case 3 => "rd"
	  case _ => "th"
	}

Обратите внимание, что использование `returns` тоже имеет свою цену: при использовании внутри замыкания,

	seq foreach { elem =>
	  if (elem.isLast)
	    return
	  
	  // process...
	}
	
.LP в байт-коде это реализовано в виде пары исключений catching/throwing, использование которых в реальном коде, влияет на производительность.

### Циклы `for` и включения

`for` обеспечивает краткий и натуральный способ для циклической обработки данных и их накопления. Это особенно полезно, когда обрабатывается много последовательностей.
Синтаксис `for` противоречит основному механизму выделения и управления замыканиями. Это может привести к непредвиденным расходам и двусмысленности, например

	for (item <- container) {
	  if (item != 2) return
	}

. LP может привести к ошибке выполнения, если произойдет задержка при вычислениеи container, что делает <code>return</code> не локальным!

По этим причинам, обычно предпочтительнее, вызвать `foreach`,
`flatMap`, `map` и `filter` напрямую - но использовать `for`, чтобы прояснить вычисления.

### `require` и `assert`

`require` и `assert`, оба оператора описаны в документации. Оба полезны для ситуаций, в которых система типов не может определить нужный вариант. `require`, используется для *invariants*, которые предполагаются в коде (или
внутреннем или внешнем), например

	val stream = getClass.getResourceAsStream("someclassdata")
	assert(stream != null)

В то время как `require` используется для представления API контрактов:

	def fib(n: Int) = {
	  require(n > 0)
	  ...
	}

## Функциональное программирование

*Программирование ориентированное на значение* дает много преимуществ, особенно когда используется в сочетании с конструкциями функционального программирования. Этот стиль
делает упор на преобразование значений вместо изменения состояния, возвращая код, который более прозрачен, обеспечивая больше инвариантов, а значит и легче в рассуждениях. Case классы, сопоставление с образцом, бессвязность, вывод типов, и легковесное замыкание - и метод - образуют синтаксис, который является предметов обсуждений.

### Case классы как алгебраический тип данных

Case классы представляют собой АТД(алгебраический тип данных): они полезны для моделирования большого числа
структур данных и обеспечивают более короткий код с сильными
инвариантами, особенно при использовании сопоставления с образцом. Сопоставление с образцом реализует исчерпывающий анализ, обеспечивая равномерные статические гарантии.

Используйте следующий образец при использовании АТД с Case классами:

	sealed trait Tree[T]
	case class Node[T](left: Tree[T], right: Tree[T]) extends Tree[T]
	case class Leaf[T](value: T) extends Tree[T]

.LP  тип <code>Tree[T]</code>имеет два конструктора: <code>Node</code> и <code>Leaf</code>. Объявление типа <code>sealed</code> позволяет компилятору сделать исчерпывающий анализ, поскольку конструкторы не могут быть добавлены за пределами исходного файла.

Вместе с использованием сопоставленя с образцом, мы получаем краткие и "очевидно правильные" результаты моделирования в коде:

	def findMin[T <: Ordered[T]](tree: Tree[T]) = tree match {
	  case Node(left, right) => Seq(findMin(left), findMin(right)).min
	  case Leaf(value) => value
	}

В то время как рекурсивные структуры, такие как деревья представляют собой классические реализации АТД, областей их полезного применения намного больше. Несвязные объединения, в частности, легко моделируется с помощью абстрактных типов данных; они часто встречаются в состояниях машины.

### Опции

Тип `Option` - это контейнер, который либо пуст (`None`), либо полон (`Some(value)`). Он обеспечивает безопасную альтернативу использованию `null`, и должен быть использован вместо null всякий раз, когда это возможно. Эти типы являются коллекциями (содержащими не более одного элемента) и они используют методы коллекций - используйте их!

Пишите

	var username: Option[String] = None
	...
	username = Some("foobar")

.LP вместо

	var username: String = null
	...
	username = "foobar"

.LP первый вариант безопаснее: тип <code>Option</code> статически проверяет что <code>Username</code> должен быть проверен на пустоту.

Условное выполнение `Option` значений должно быть сделано с
 помощью `foreach`, вместо

	if (opt.isDefined)
	  operate(opt.get)

.LP пишите

	opt foreach { value =>
	  operate(value)}

Стиль может показаться странным, но обеспечивает большую безопасность (мы не вызываем исключительно `get`) и краткость. Если есть два варианта выполнения, то при использовании сопоставлении с образцом:

	opt match {
	  case Some(value) => operate(value)
	  case None => defaultAction()
	}

.LP но если все варианты ложные, то для значения по умолчанию, используйте <code>getOrElse</code>

	operate(opt getOrElse defaultValue)

Не злоупотребляйте `Option`: если имеется значение по 
умолчанию - [*Null Object*](http://en.wikipedia.org/wiki/Null_Object_pattern) - используйте его.

`Option` также предоставляет удобный конструктор для упаковки nullable значения:

	Option(getClass.getResourceAsStream("foo"))

.LP является <code>Option[InputStream]</code> которая может  принимать значение <code>None</code>, в этом случае <code>getResourceAsStream</code> должен возвратить <code>null</code>.

### Сопоставление с образцом

Сопоставление с образцом (`x match { ...`) широко распространено в хорошо написанном Scala коде: оно осуществляет условное выполнение, разбор конструкций, и все это в одной конструкции. При его использовании также повышается четкость и безопасность.

Используйте сопоставление с образцом для реализации переключения типов:

	obj match {
	  case str: String => ...
	  case addr: SocketAddress => ...
 
Сопоставление с образцом лучше всего работает в сочетании с разбором конструкций (например, работе с Case классами), вместо

	animal match {
	  case dog: Dog => "dog (%s)".format(dog.breed)
	  case _ => animal.species
	  }

.LP лучше написать

	animal match {
	  case Dog(breed) => "dog (%s)".format(breed)
	  case other => other.species
	}


Используйте [custom extractors](http://www.scala-lang.org/node/112), но только с дополнительным конструктором (`apply`), в противном случае их использования может быть неуместным.

Не используйте сопоставление с образцом для вычисления условий, когда имеет смысл использовать стандартные значения. Библиотеки коллекций  обычно предоставляет методы, которые возвращают `Option`; избегайте

	val x = list match {
	  case head :: _ => head
	  case Nil => default
	}

.LP потому что

	val x = list.headOption getOrElse default

.LP так короче и болешь соответствует цели

### Частичные функции

Scala предоставляет синтаксический сахар для определения `PartialFunction`:

	val pf: PartialFunction[Int, String] = {
	  case i if i%2 == 0 => "even"
	}

.LP и они могут использоваться вместе с <code>orElse</code>

	val tf: (Int => String) = pf orElse { case _ => "odd"}

	tf(1) == "odd"
	tf(2) == "even"

Частичные функции исопльзуются во многих ситуациях и эффективно
кодируются с помощью `PartialFunction`, например, в качестве аргументов
методов

	trait Publisher[T] {
	  def subscribe(f: PartialFunction[T, Unit])
	}

	val publisher: Publisher[Int] = ..
	publisher.subscribe {
	  case i if isPrime(i) => println("found prime", i)
	  case i if i%2 == 0 => count += 2
	  /* ignore the rest */
	}

.LP или в ситуациях, которые могли бы способствовать возврату <code>Option</code>

	// Attempt to classify the the throwable for logging.
	type Classifier = Throwable => Option[java.util.logging.Level]

.LP может быть лучше выражено с помощью <code>PartialFunction</code>

	type Classifier = PartialFunction[Throwable, java.util.Logging.Level]

.LP так как это более компактно:

	val classifier1: Classifier
	val classifier2: Classifier

	val classifier = classifier1 orElse classifier2 orElse { _ => java.util.Logging.Level.FINEST }


### Ликвидация привязок (Destructuring bindings)

Ликвидация привязок тесно связана с сопоставлением с образцом; используется тот же механизм, но применяется, когда есть только один вариант (чтобы не сгенерировать исключение). Ликвидация привязок особенна полезны для кортежей и Case классов.

	val tuple = ('a', 1)
	val (char, digit) = tuple

	val tweet = Tweet("just tweeting", Time.now)
	val Tweet(text, timestamp) = tweet

### Ленивые вычисления

Поля в Scala вычисляется *по необходимости*, когда `val` имеет префикс
 `lazy`. Поэтому поля и методы в Scala эквиваленты (поля как бы `private[this]`)

	lazy val field = computation()

.LP это примерное сокращение для

	var _theField = None
	def field = if (_theField.isDefined) _theField.get else {
	  _theField = Some(computation())
	  _theField.get
	}

.LP то есть, результаты вычисляются и запоминаются. Используйте ленивые поля для этого, но избегайте использования ленивых вычислений, когда ленивые вычисления требуются по смыслу. В этих случаях лучше производить вычисления явно, поскольку можно точно произвести оценку, и побочные эффекты могут контролироваться более точно.

Ленивые поля являются потокобезопасными.

### Передача по имени

Параметры методов могут быть переданы по имени, то есть параметр принимает не значение, а *вычисление*, которое может повторяться. Это
функция должна применяться с осторожностью; вызывающая функция может ожидать передачу по значению, но в ответ будет удивлена. Способ применения этой особенности - это построение обычных синтаксических DSL - например, могут быть сделаны новые конструкции управления, чтобы выглядеть так же, как и родные особенности языка.

Используйте передачу по имени управляющих конструкций, когда для вызывающей функции очевидно, что передается в это "блок", а не
результат каких-то неожиданных вычислений. Используйте передачу по имени в крайней позиции последнего списка аргументов. При использовании передачи по имени, убедитесь, что метод назван очевидным образом для вызывающей функуции, которая передает аргумент.

Если вы хотите, чтобы значения вычислялись несколько раз, и, особенно, когда вычисление имеет побочные эффекты, используйте явные функции:


	class SSLConnector(mkEngine: () => SSLEngine)

.LP ваше намерение остается очевидным и для вызывающей функции это не будет сюрпризом

### `flatMap`

`map` と `flatten` の合成である `flatMap` は、鋭敏な力と素晴らしい実用性を持ち、特別な注目を浴びるに値する。
その同類である `map` のように、`Future` や `Option` といった非伝統的なコレクションにおいて、頻繁に利用できる。
その振る舞いは、`Container[A]`といったシグネチャによって明らかになる。
 
	flatMap[B](f: A => Container[B]): Container[B]

.LP <code>flatMap</code> は、<em>新しい</em> コレクションを生成するコレクションの各要素に対して関数 <code>f</code> を呼び出し、それら(のすべて)は、
フラットな結果になる。例えば、次のコードは、同じ文字が繰り返されない2文字からなる文字列の順列をすべて取得する。
 
	val chars = 'a' to 'z'
	val perms = chars flatMap { a =>
	  chars flatMap { b =>
	    if (a != b) Seq("%c%c".format(a, b))
	    else Seq()
	  }
	}

.LP これは、より簡潔な for による包含に等価である。(それは、&mdash; 荒くまとめるなら &mdash; 上記のためのシンタックスシュガーである)
 
	val perms = for {
	  a <- chars
	  b <- chars
	  if a != b
	} yield "%c%c".format(a, b)

`flatMap` は、(Optionの連鎖(chain of options)を畳み込んでひとつにするときなど) `Option` を扱うときに頻繁に役に立つ。
 
	val host: Option[String] = ..
	val port: Option[Int] = ..
	
	val addr: Option[InetSocketAddress] =
	  host flatMap { h =>
	    port map { p =>
	      new InetSocketAddress(h, p)
	    }
	  }

.LP これも、<code>for</code> を使えばもっと簡潔に記述できる。
 
	val addr: Option[InetSocketAddress] = for {
	  h <- host
	  p <- port
	} yield new InetSocketAddress(h, p)

`Future` における `flatMap` の利用については、<a href="#Twitter's%20standard%20libraries-Futures">futures section</a> で議論されている。

## オブジェクト指向プログラミング

Scala の広大な広がりの大部分はオブジェクト機構にある。Scala は、 *すべての値* がオブジェクトであるという意味で、 *純粋な* 言語である。プリミティブな型と混合型の間に違いはない。 Scala はミックスインの機能もあり、静的型チェックの利益をすべて享受しつつ、もっと直行して別々なモジュールをコンパイル時に柔軟に一緒に組立てられる。

ミックスイン機構の背景ある動機は、伝統的な依存性注入を不要にすることである。その"コンポーネントスタイル"プログラミングの極致は、 [Cake
パターン](http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di/) である。

（訳注: 上記のCakeパターンに関するエントリは、@eed3si9n氏が[日本語訳](http://eed3si9n.com/ja/real-world-scala-dependency-injection-di)を提供している。）

### 依存性注入

しかし、我々の場合、Scala それ自身が、"クラシックな"（コンストラクタによる）依存性注入(dependency injection)の多くの構文上のオーバーヘッドを排除してくれるため、むしろ、使うようにしている。それはより明快であり、依存性は(コンストラクタの)型でまだエンコードされ、クラスの組立は構文上、そよ風並に些細な作業に過ぎない。それは退屈でシンプルだが動作する。*プログラムのモジュール化のために依存性注入を使うことだ*。特に、*継承より合成を選択することだ* 。これにより、よりモジュール化が進みテスト可能なプログラムになる。継承が必要な状況に遭遇した際には自分自身に問うのだ：もし、言語が継承をサポートしていなかったら、どのように構造化するだろう、と。この答えは強いることができるかもしれない。

依存性注入は典型的にはトレイトを利用する。

     trait TweetStream {
       def subscribe(f: Tweet => Unit)
     }
     class HosebirdStream extends TweetStream ...
     class FileStream extends TweetStream ..

     class TweetCounter(stream: TweetStream) {
       stream.subscribe { tweet => count += 1 }
     }

*ファクトリー* (オブジェクトを生成するオブジェクト)を注入することは一般的である。以下のような場合には、特化したファクトリー型よりはシンプルな関数の利用を好むようにする。

     class FilteredTweetCounter(mkStream: Filter => TweetStream) {
       mkStream(PublicTweets).subscribe { tweet => publicCount += 1 }
       mkStream(DMs).subscribe { tweet => dmCount += 1 }
     }

### トレイト

依存性注入は、一般的な *インターフェイス* の利用や、トレイト(trait)での共通コードの実装を妨げるものでは全くない。むしろ全く反対であり、トレイトの利用は正確には次の理由で強く推奨されている：複数のインターフェイス(トレイト)は、具象クラスで実装されるかもしれないし、共通コードはすべてのそれらのクラス群に横断的に再利用されるかもしれない。

トレイトは短くて直交するように保つことだ。分割可能な機能をひとつのトレイトの塊にしてしまってはいけない。最も小さな関連するアイデアだけを一緒にすることを考えるようにする。たとえば、IOをする何かを想像してみるといい。

     trait IOer {
       def write(bytes: Array[Byte])
       def read(n: Int): Array[Byte]
     }

.LP これを２つの振る舞いに分離する。

     trait Reader {
       def read(n: Int): Array[Byte]
     }
     trait Writer {
       def write(bytes: Array[Byte])
     }

.LP そして、もともと<code>IOer</code> だったこれらを、 <code>new Reader with Writer</code>&hellip; のようにミックスする。インターフェイスの最小化は、よりよい直交性とよりよりモジュール化につながる。

### 可視性

Scala は非常に表現豊かな可視性を制御する修飾子を持つ。修飾子は、何を *公開API* として構成するかを定義するのに重要である。公開APIは限定されるべきであり、それにより利用者は不注意に実装の詳細に依存することはなくなり、また、作者のAPIを変更する力を制限する。このことは、良いモジュール性にとって決定的に重要である。ルールとして、公開APIを拡張することは、彼らと契約するよりも全然簡単である。貧相なアノテーションは、君のコードの後方バイナリ互換性を汚すこともできるようにもなる。


#### `private[this]`

`private` にしたクラスメンバーは、

     private val x: Int = ...

.LP そのクラスの(サブクラスは含まない)すべての<em>インスタンス</em>から見える。殆どの場合、<code>private[this]</code>としたいだろう。

     private[this] val: Int = ..

.LP これで特定のインスタンスのみに可視性は制限された。Scala コンパイラーは、<code>private[this]</code> を(静的に定義されたクラスにアクセスが限られるから)シンプルなフィールドアクセッサに変換することもでき、それは時々、性能を最適化することに寄与する。

#### シングルトンクラス型

Scala では、シングルトンクラス型を生成することは一般的である。例えば、

     def foo() = new Foo with Bar with Baz {
       ...
     }

.LP このような状況では、戻り型を宣言することで可視性は限定される。

     def foo(): Foo with Bar = new Foo with Bar with Baz {
       ...
     }

.LP <code>foo()</code> の呼び出し側は、戻り値のインスタンスの限定されたビュー(<code>Foo with Bar</code>) を参照する。

### 構造的部分型

構造的部分型(structural type)は通常は使わない。構造的部分型は、便利で強力な機能であるが、残念なことに JVM 上では効率的な実装手段はない。しかし、ある運命のいたずらともいうべき実装によって、リフレクションをするためのとても良い速記法を提供する。

     val obj: AnyRef
     obj.asInstanceOf[{def close()}].close()

（訳注: "structural typing"を直訳すると「構造的な型付け」だが、Scalaの文脈では「構造的部分型(structural subtyping)」と同じ意味だと考えて良い。この用語の背景については、[@kmizu氏による解説](https://github.com/scalajp/effectivescala/pull/1#r455268)を参照して欲しい。）

## ガベージコレクション

我々は、運用時にガベージコレクションのチューニングに多くの時間を費やす。
ガベージコレクションの考慮事項はかなりJavaのそれに似ているが、典型的な Scala コードの場合は 典型的な Java コードより多くの(生存時間の短い)ガベージを生成する。これは関数スタイルの副作用なのである。HotSpot の世代別ガベージコレクションは、ほとんどの環境では生存時間の短いガベージを効果的に解放するので、概してこれは問題にならない。

GCの性能問題に取り組む前に、Attila が発表した我々のGCチューニングに関する経験のいくつかに関する[プレゼンテーション](http://www.infoq.com/presentations/JVM-Performance-Tuning-twitter)を見て欲しい。


Scala 固有で、GC問題を軽減する唯一のツールは、ガベージの生成をより少なくすることである。しかし、データなしで行動してはならない！もし、明らかに悪化させる何かをしているわけではないのであれば、我々の提供する [heapster](https://github.com/mariusaeriksen/heapster) や
[gcprof](https://github.com/twitter/jvmgcprof) を含む、Java の様々なプロファイルツールを使うことだ。

## Java 互換性

我々は、Javaで利用されるようなコードを Scala で書くとき、Javaでの使い方を慣用的に残して良いものか確かめるようにしている。大体は余計な努力は必要ない。クラス群と実装を含まないトレイトはJava に正確に等価に対応される。しかし、時々、別に Java API を提供する必要がある。あなたのライブラリのJava API の感じをつかむ良い方法は単体テストをJavaで書くことである(ただコンパイルが通れば良い)。この点については Scala コンパイラーは不安定であるのだが、このテストによって、あなたのライブラリの Java 視点は安定さを維持できる。

実装を含むトレイトは直接 Java から利用できない。代わりに抽象クラスをトレイトと共に拡張する必要がある。

     // 直接 Java からは利用できない
     trait Animal {
       def eat(other: Animal)
       def eatMany(animals: Seq[Animal) = animals foreach(eat(_))
     }

     // しかし、これなら利用できる
     abstract class JavaAnimal extends Animal

## Twitterの標準ライブラリ

Twitterにおいて、最も重要な標準ライブラリは[Util](http://github.com/twitter/util)と[Finagle](https://github.com/twitter/finagle)だ。Utilは、ScalaやJavaの標準ライブラリの拡張という位置付けで、それらに欠けている機能やより適切な実装を提供する。Finagleは、TwitterのRPCシステムで、分散システムの構成要素の中核だ。

### Future

Futureについては、<a href="#並行性">並行性</a>の章でも少し<a href="#並行性-Future">議論した</a>。Futureは、非同期処理の連係において重要な機構で、TwitterのコードベースやFinagleのコアで広く使われている。Futureは、並行イベントの合成(composition)を可能にすると共に、高度な並行操作についての判断を単純化する。また、Futureを使うと、並行操作をJVM上で極めて効率的に実装できる。

ネットワーク入出力やディスク入出力等の操作は、基本的にスレッドの実行を一時停止する可能性がある。TwitterのFutureは*非同期的*なので、ブロックする操作(blocking operation)は、操作結果に対するFutureを提供するシステム自身によって処理されなければいけない。Finagleは、ネットワーク入出力のためのそうしたシステムを提供する。

Futureは、単純明白だ。Futureは、まだ完了していない計算の結果に対する*約束(promise)*を保持する、単純なコンテナ（プレースホルダ）だ。当然、計算は失敗することがあるので、このこともコード化する必要がある。Futureは三つの状態、すなわち*保留(pending)*、*失敗(failed)*、*完了(completed)*のうち、きっかり一つの状態を取ることができる。

<div class="explainer">
<h3>余談: <em>合成(composition)</em></h3>
<p>もう一度確認すると、合成とは、単純なコンポーネントを結合してより複雑なコンポーネントにすることだ。合成の標準的な例は、関数合成だ。関数<em>f</em>と<em>g</em>が与えられたとき、合成関数<em>(g&#8728;f)(x) = g(f(x))</em>は、まず<em>x</em>を<em>f</em>に適用し、その結果を<em>g</em>に適用した結果だ。この合成関数をScalaで書くと:</p>

<pre><code>val f = (i: Int) => i.toString
val g = (s: String) => s+s+s
val h = g compose f  // : Int => String
	
scala> h(123)
res0: java.lang.String = 123123123</code></pre>

.LP この関数<em>h</em>は合成関数で、<em>f</em>と<em>g</em>の双方を所定の方法で結合した<em>新しい</em>関数だ。
</div>

Futureは、ゼロ個あるいは一個の要素を持つコンテナであり、コレクションの一種だ。Futureは、`map`や`filter`や`foreach`といった、標準コレクションのメソッドを持つ。Futureの値は遅延されるので、必然的にこれらのコレクションメソッドを適用した結果もまた遅延される。

	val result: Future[Int]
	val resultStr: Future[String] = result map { i => i.toString }

.LP 関数<code>{ i => i.toString }</code>は、Int値が利用可能になるまで呼び出されない。また、変換されたコレクションである<code>resultStr</code>も、その時まで保留状態(pending state)になる。

リストは平坦化(flatten)できる;

	val listOfList: List[List[Int]] = ..
	val list: List[Int] = listOfList.flatten

.LP また、平坦化はFutureにおいても意味をなす:

	val futureOfFuture: Future[Future[Int]] = ..
	val future: Future[Int] = futureOfFuture.flatten

.LP Futureの<code>flatten</code>の実装は、直ちにFutureを返す。Futureは遅延するので、<code>flatten</code>が返すFutureは、外側のFuture(<code><b>Future[</b>Future[Int]<b>]</b></code>)の完了と、その後に内側のFuture(<code>Future[<b>Future[Int]</b>]</code>)の完了を待つ結果だ。また、外側のFutureが失敗したら、平坦化されたFutureも失敗する必要がある。

Futureは、Listと同様に`flatMap`を定義している。`Future[A]`は、そのシグネチャを以下のように定義する。

	flatMap[B](f: A => Future[B]): Future[B]
	
.LP `flatMap`は、<code>map</code>と<code>flatten</code>の組み合わせのようなもので、以下のように実装できる:

	def flatMap[B](f: A => Future[B]): Future[B] = {
	  val mapped: Future[Future[B]] = this map f
	  val flattened: Future[B] = mapped.flatten
	  flattened
	}

これは、強力な組み合わせだ！ `flatMap`によって、二番目のFutureを最初のFutureの結果に基づいて計算する、順番に並べられた二つのFutureの結果である新しいFutureを定義できる。ユーザ(ID)を認証するために、二つのRPCを実行する必要がある場合を想像してほしい。この場合、合成された操作を以下の方法で定義できる:

	def getUser(id: Int): Future[User]
	def authenticate(user: User): Future[Boolean]
	
	def isIdAuthed(id: Int): Future[Boolean] = 
	  getUser(id) flatMap { user => authenticate(user) }

.LP この種の結合のもう一つの恩恵は、エラー処理が組み込まれていることだ。<code>getUser(..)</code>か<code>authenticate(..)</code>が追加でエラー処理をしない限り、<code>isAuthed(..)</code>が返すFutureは失敗するだろう。

#### スタイル

Futureのコールバックメソッドである`respond`や`onSuccess`、`onFailure`、`ensure`は、その親に*連鎖した(chained)*新たなFutureを返す。このFutureは、その親が完了して初めて完了することが保証されている。このパターンを実現するには、例えば以下のようにする。

	acquireResource()
	future onSuccess { value =>
	  computeSomething(value)
	} ensure {
	  freeResource()
	}

.LP このとき<code>freeResource()</code>は、<code>computeSomething</code>の後にのみ実行されることが保証される。これにより、ネイティブな<code>try .. finally</code>パターンのエミュレートが可能になる。

`foreach`の代わりに`onSuccess`を使おう。`onSuccess`の方が`onFailure`と対称を成して目的をより良く表せるし、連鎖も可能になる。

なるべく、`Promise`インスタンスを直接作らないようにしよう。ほぼ全てのタスクは、定義済みの結合子を使って実現できる。結合子は、エラーやキャンセルが伝播することを保証すると共に、一般的に*データフロー方式*でのプログラミングを促進する。データフロー方式を使うと、大抵、<a href="#並行性-Future">同期化や`volatile`宣言が不要になる</a>。

末尾再帰方式で書かれたコードは、スタック空間のリークを引き起こさないので、データフロー方式を使ってループを効率的に実装できる:

	case class Node(parent: Option[Node], ...)
	def getNode(id: Int): Future[Node] = ...

	def getHierarchy(id: Int, nodes: List[Node] = Nil): Future[Node] =
	  getNode(id) flatMap {
	    case n@Node(Some(parent), ..) => getHierarchy(parent, n :: nodes)
	    case n => Future.value((n :: nodes).reverse)
	  }

`Future`は、数多くの有用なメソッドを定義している。`Future.value()`や`Future.exception()`を使うと、事前に結果が満たされたFutureを作れる。`Future.collect()`や`Future.join()`、`Future.select()`は、複数のFutureを一つにまとめる結合子を提供する（ie. scatter-gather操作のgather部分）。

#### キャンセル

Futureは、弱いキャンセルを実装している。`Future#cancel`の呼び出しは、計算を直ちに終了させるのではなく、レベルトリガ方式の*シグナル*を伝播する。最終的にFutureを満たすのがいずれの処理であっても、シグナルに問い合わせる(query)ことができる。キャンセルは、値から反対方向へ伝播する。つまり、消費者(consumer)がセットしたキャンセルのシグナルは、対応する生産者(producer)へと伝播する。生産者は`Promise`にある`onCancellation`を使って、シグナルに応じて作動するリスナーを指定する。

つまり、キャンセルの動作は生産者に依存し、デフォルトの実装は存在しない。*キャンセルはヒントに過ぎない。*

#### Local

Utilライブラリの[`Local`](https://github.com/twitter/util/blob/master/util-core/src/main/scala/com/twitter/util/Local.scala#L40)は、ローカルから特定のFutureのディスパッチツリーへの参照セルを提供する。`Local`の値をセットすると、同じスレッド内のFutureによって遅延されるあらゆる計算が、この値を利用できるようになる。これらはスレッドローカルに似ているけど、そのスコープはJavaのスレッドでなく、"Futureスレッド"のツリーだ。

	trait User {
	  def name: String
	  def incrCost(points: Int)
	}
	val user = new Local[User]

	...

	user() = currentUser
	rpc() ensure {
	  user().incrCost(10)
	}

.LP ここで、<code>ensure</code>ブロックの中の<code>user()</code>は、コールバックが追加された時点での<code>user</code>(Local)の値を参照する。

スレッドローカルと同様に`Local`は非常に便利なこともあるが、ほとんどの場合は避けるべきだ。データを明示的に渡して回るのは、たとえそうした方が負担が少なくても、問題を十分に解決できないことを確認しよう。

Localは、RPCのトレースを介したスレッド管理や、モニターの伝播、Futureコールバックのための"スタックトレース"の作成など、*とても*一般的な関心事(concern)を実現する際に、その他の解決策ではユーザに過度な負担がある場合、コアとなるライブラリにおいて効果的に使われる。Localは、その他のほとんどの場面では不適切だ。

### OfferとBroker

並行システムは非常に複雑だ。それは、共有データやリソースへのアクセスを協調させる必要があるからだ。[Actor](http://www.scala-lang.org/api/current/scala/actors/Actor.html)は、単純化の一つの戦略を提起している。Actorはシーケンシャルなプロセスで、それぞれが自分自身の状態やリソースを保持している。そして、データは、他のActorとのメッセージングによって共有される。共有データは、Actor間で通信する必要がある。

OfferとBrokerは、これに基づいて、三つの重要な考え方を取り入れている。一つ目、通信チャネル(Broker)は第一級(first class)だ。すなわち、Actorに直接メッセージを送るのではなく、Broker経由で送信する。二つ目、OfferやBrokerは同期化メカニズムであり、通信することは同期化することだ。これは、Brokerが協調メカニズムとして使えることを意味する。プロセス`a`がプロセス`b`にメッセージを送信したとき、`a`と`b`の両方とも、システムの状態について合意する。三つ目、通信は*選択的に*実行できる。一つのプロセスは、いくつかの異なる通信を提案でき、それらのうち、ただ一つが有効になる。

一般的な（他の合成と同様の）やり方で選択的な通信をサポートするには、通信行為(act of communicating)から通信の記述(description of a communication)を分離する必要がある。これをやるのが`Offer`だ。Offerは通信を記述する永続的な値であり、通信を（Offerに従って）実行するには、`sync()`メソッドによって同期化する。

	trait Offer[T] {
	  def sync(): Future[T]
	}

.LP `sync()`メソッドは、通信が行われた時にやり取りされた値を生成する<code>Future[T]</code>を返す。

`Broker`は、Offerを介して値のやり取りを協調する。Brokerは通信のチャネルだ:

	trait Broker[T] {
	  def send(msg: T): Offer[Unit]
	  val recv: Offer[T]
	}

.LP そして、二つのOfferを生成するとき、

	val b: Broker[Int]
	val sendOf = b.send(1)
	val recvOf = b.recv

.LP <code>sendOf</code>と<code>recvOf</code>はどちらも同期化されており、

	// In process 1:
	sendOf.sync()

	// In process 2:
	recvOf.sync()

.LP どちらのOfferも有効になり、<code>1</code>の値がやり取りされる。

選択的な通信は、いくつかのOfferを`Offer.choose`で結合することにより実行される。

	def choose[T](ofs: Offer[T]*): Offer[T]

.LP は、同期化すると<code>ofs</code>のうち、最初に利用可能になった唯一つのOfferを有効とする、新しいOfferを生成する。いくつかが即座に利用可能になった場合は、有効になる`Offer`はランダムに選ばれる。

`Offer`オブジェクトは、一個限りのOfferをいくつも持っており、BrokerからのOfferを組み立てるために使用される。

	Offer.timeout(duration): Offer[Unit]

.LP は、与えられた期間の後に起動するOfferだ。<code>Offer.never</code>は、決して有効にならない。また、<code>Offer.const(value)</code>は、与えられた値が直ちに有効になる。選択的な通信を用いて合成するのにも有用だ。例えば、送信操作でタイムアウトを適用するときは:

	Offer.choose(
	  Offer.timeout(10.seconds),
	  broker.send("my value")
	).sync()

OfferとBrokerを使う方法と、[SynchronousQueue](http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/SynchronousQueue.html)を比べてみたくなるかもしれないが、両者には微妙だが重要な違いがある。Offerは組み立てることができるが、SynchronousQueueのようなキューでは、とてもそんなことはできない。例えば、Brokerで表される一連のキューを考えると:

	val q0 = new Broker[Int]
	val q1 = new Broker[Int]
	val q2 = new Broker[Int]
	
.LP ここで、読み込みのための結合されたキューを作ってみると:

	val anyq: Offer[Int] = Offer.choose(q0.recv, q1.recv, q2.recv)
	
.LP <code>anyq</code>はOfferで、最初に利用可能になったキューから読み込む。ここで、<code>anyq</code>はやはり同期的であり、内部にあるキューの動作を利用できる。こうした合成は、キューを使う方法ではとても不可能だ。
	
#### 例: 簡単なコネクションプール

コネクションプールはネットワークアプリケーションでは一般的なもので、たいていは実装がとても難しい。例えば、個々のクライアントは異なるレイテンシを要求するため、多くの場合、プールからの取得にタイムアウトを持つことが望ましい。プールは、原理的には単純だ。コネクションのキューを保持し、待機クライアント(waiter)が入ってきたら要求を満たしてやる。従来の同期化プリミティブでは、典型的には二つのキューを保持する。一つはwaiterで、コネクション(connection)がない時に使われる。もう一つはconnectionで、これは待機クライアント(waiter)がない時に使われる。

OfferとBrokerを使うと、これをとても自然に表現できる:

	class Pool(conns: Seq[Conn]) {
	  private[this] val waiters = new Broker[Conn]
	  private[this] val returnConn = new Broker[Conn]

	  val get: Offer[Conn] = waiters.recv
	  def put(c: Conn) { returnConn ! c }
	
	  private[this] def loop(connq: Queue[Conn]) {
	    Offer.choose(
	      if (connq.isEmpty) Offer.never else {
	        val (head, rest) = connq.dequeue
	        waiters.send(head) { _ => loop(rest) }
	      },
	      returnConn.recv { c => loop(connq enqueue c) }
	    ).sync()
	  }
	
	  loop(Queue.empty ++ conns)
	}

`loop`は、返却されたコネクションを持つことを常にオファー(offer)し、キューが空でない時のみ送信をオファーする。永続的なキューを使うことで、推論をより単純にできる。プールに対するインタフェースもOfferを介しているから、もし呼び出し側がタイムアウトを適用したいなら、コンビネータを使うことで可能だ:

	val conn: Future[Option[Conn]] = Offer.choose(
	  pool.get { conn => Some(conn) },
	  Offer.timeout(1.second) { _ => None }
	).sync()

タイムアウトの実装に余計な簿記は必要とされない。これは、Offerの動作によるものだ: もし`Offer.timeout`が選択されたら、もはやプールからの受信をオファーしない。つまり、プールと呼び出し側がそれぞれ、Brokerである`waiters`上で送信と受信を同時に合意することはない。

#### 例: エラトステネスの篩

並行プログラムを、同期的に通信する一連のシーケンシャルなプロセスとして構築するのは、多くの場合で有用だし、時としてプログラムを非常に単純化できる。OfferとBrokerは、これを単純化しかつ統一化する手段を提供する。実際、それらのアプリケーションは、人が"古典的な"並行性の問題だとみなすかもしれないことを乗り越える。（OfferやBrokerを用いた）並行プログラミングは、サブルーチンやクラス、モジュールと同じように、有用な*構造化*ツールだ。これは、制約充足問題(Constraint Satisfaction Problem; CSP)からのもう一つの重要なアイデアだ。

この一つの例は[エラトステネスの篩](http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9)で、整数ストリームに対するフィルタの連続的な適用として構造化できる。まず、整数の生成源が必要だ:

	def integers(from: Int): Offer[Int] = {
	  val b = new Broker[Int]
	  def gen(n: Int): Unit = b.send(n).sync() ensure gen(n + 1)
	  gen(from)
	  b.recv
	}

.LP <code>integers(n)</code>は、<code>n</code>から始まる全ての連続した整数の単純なOfferだ。次に、フィルタが必要だ:

	def filter(in: Offer[Int], prime: Int): Offer[Int] = {
	  val b = new Broker[Int]
	  def loop() {
	    in.sync() onSuccess { i =>
	      if (i % prime != 0)
	        b.send(i).sync() ensure loop()
	      else
	        loop()
	    }
	  }
	  loop()
	
	  b.recv
	}

.LP <code>filter(in, p)</code>は、<code>in</code>から素数<code>p</code>の倍数を取り除くOfferを返す。最後に、篩(sieve)を定義する:

	def sieve = {
	  val b = new Broker[Int]
	  def loop(of: Offer[Int]) {
	    for (prime <- of.sync(); _ <- b.send(prime).sync())
	      loop(filter(of, prime))
	  }
	  loop(integers(2))
	  b.recv
	}

.LP <code>loop()</code>の動作は単純だ: <code>of</code>から次の素数を読み取った後、この素数を除外した<code>of</code>にフィルタを適用する。<code>loop</code>が再帰するにつれて連続した素数がフィルタされ、篩が手に入る。今や、我々は最初から10000個の素数を出力できる:

	val primes = sieve
	0 until 10000 foreach { _ =>
	  println(primes.sync()())
	}

このアプローチは、単純かつ直行的なコンポーネントへと構造化できることに加えて、篩をストリームとして扱える。君は、興味がある素数の集合を演繹的に計算したり、さらにモジュラリティを拡張したりする必要がない。

## 謝辞

本レッスンは、Twitter社のScalaコミュニティによるものだ。私は、誠実な記録者でありたい。

Blake MathenyとNick Kallen、Steve Gury、そしてRaghavendra Prabhuには、とても有益な助言と多くの優れた提案を与えてもらった。

### 日本語版への謝辞

本ドキュメントの日本語訳は、[@appigram](http://github.com/appigram)と[@scova0731](https://github.com/scova0731)が担当しました。

翻訳にあたっては、日本のScalaコミュニティから数多くの貢献を頂きました: [@xuwei-k](http://github.com/xuwei-k)さん、[@kmizu](http://github.com/kmizu)さん、[@eed3si9n](http://github.com/eed3si9n)さん、[@akr4](http://github.com/akr4)さん、[@yosuke-furukawa](http://github.com/yosuke-furukawa)さん、m hanadaさん、および[日本Scalaユーザーズグループ](http://jp.scala-users.org/)の皆さん。（以上、順不同）

また、[@kmizu](http://github.com/kmizu)さんと[@eed3si9n](http://github.com/eed3si9n)さんには、高度に専門的な議論について貴重な助言を頂きました。

ありがとうございます。

[Scala]: http://www.scala-lang.org/
[Finagle]: http://github.com/twitter/finagle
[Util]: http://github.com/twitter/util
