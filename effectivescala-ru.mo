<a href="http://github.com/twitter/effectivescala"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

<h1 class="header">Effective Scala</h1>
<address>Marius Eriksen, Twitter Inc.<br />marius@twitter.com (<a href="http://twitter.com/marius">@marius</a>)<br /><br />[translated by Eugene Sysmanov(<a href="https://github.com/appigram">@appigram</a>)]</address>

<h2>Table of Contents</h2>

.TOC


<h2>Другие языки</h2>
<a href="index.html">English</a>
<a href="index-ja.html">日本語</a>

## Введение

[Scala][Scala] является одним из основных языков программирования, который испоьзуется в Twitter. Большая часть нашей инфрастуктуры написана на Scala и [у нас есть несколько крупных библиотек](http://github.com/twitter/) поддерживается нами.

Scala не только очень эффективный, но также и большой язык, полученный нами опыт, научил нас быть очень осторожным при его использовании на практике в своем приложении. Где скрыты подводные камни? Какие особенности стоит использвать, а от каких отказаться? Когда мы можем использовать «чисто функциональный стиль», а когда его следует избегать? Другими словами: что мы используем, чтобы быть более эффективными при использовании языка? Это руководство пытается передать наш опыт в коротких заметках, представляя набор *лучших практик*. Мы используем Scala для создания высококачественных услуг, которые представляют собой распределенные системы - наше мнение возможно будет предвзято - но большинство советов здесь должны работать без проблем и 
при переносе на другие системы. Все это не истина в последней инстанции, и отклонение должно быть вполне приемлимым.


Scala предоставляет множество инструментов, которые позволяют кратко описывать свои действия. Если мы меньше будем набирать символов, значит меньше придется читать, а значит исходный код будет прочитан быстрее, из этого следует, что краткость повышает ясность. Однако краткость может быть и тупым инструментом, который может оказать обратный эффект: вслед за правильностью, всегда нужно думать о читателе.

Немного, о *программе на Scala*. Вы не пишете код ни на Java, ни на Haskell, ни на Python; написание Scala-программы отличается от написания в любом из этих языков. Для того чтобы использовать язык эффективно, вы должны описать свои проблемы, в терминах этого языка. Вас никто не принуждает использовать программу, написанную на Java, в Scala, в большинстве случаев она будет уступать оригиналу.

Данный документ не введение в язык Scala, мы предполагаем, что читатель
знаком с языком. Вот некоторые ресурсы для обучения языку Scala:

* [Scala School](http://twitter.github.com/scala_school/)
* [Learning Scala](http://www.scala-lang.org/node/1305)
* [Learning Scala in Small Bites](http://matt.might.net/articles/learning-scala-in-small-bites/)

Данные статьи - это живой документ, который будет меняться с учетом наших текущих "лучших практик", но его основные идеи вряд ли изменятся: писать код, который всегда легко читаем; писать универсальный код, но не в ущерб
ясности; пользоваться простыми функциями языка, которые обладают большой
мощью, но избегать эзотерических функций (особенно в системе типов).
Прежде всего, всегда нужно находить компромиссы в том, что вы делаете.Сложность языка требуется в комплексных реализациях, потому что она порождает сложность: в рассуждениях, в семантике, во взаимодействия между особенностями системы, а также в понимании между вашими сотрудниками. Таким образом, трудность является производной сложности - вы всегда должны убедиться, что ее полезность превышает ее стоимость.

И получайте удовольствие.

## Форматирование

Специфические способы *форматирования кода* - пока они практичны -
не имеют большого значения. По определению, стиль не может быть хорошим или плохим, почти все определяет личное предпочтение. Однако, *последовательное* применение одних и тех же правил форматирования будет почти всегда увеличивать удобочитаемость. Читатель, уже знакомый с данным стилем, не должен разбираться в еще одном наборе местных соглашений или расшифровать еще одну часть языковой грамматики.

Это имеет особое значение для Scala, поскольку у его грамматики высокий уровень вхождения. Один говорящий пример - вызов метода: Методы
может быть вызваны с помощью "`.`", либо с использованием пробела, либо без круглой скобки для не возвращающих значений или унарных методов, с круглой скобкой для них, и так далее. Кроме того, различные стили вызова метода оставляют двусмысленность в его грамматике! Конечно, последовательное применение тщательно выбранного набора правил форматирования решит большую часть двусмысленности и для человека и для машины.

Мы придерживаемся [Правила форматирования в языке Scala] (http://docs.scala-lang.org/style/) и дополнительно следующих правил.

### Пробельные символы

При отступе используется 2 пробельных символа. Мы стараемся избегать строк, длиной более 100 символов. Мы используем одну пустую строку между методом, классом и определениями объекта.

### Именование

<dl class="rules">
<dt>Используйте короткие имена для небольших областей видимости</dt>
<dd>Применяйте <code>i</code>,<code>j</code> и <code>k</code> и подобне переменные в циклах </dd>
<dt>Используйте длинные имена для больших областей видимости</dt>
<dd>Внешние API должны иметь длинные и понятные имена, которые придают смысл.
<code>Future.collect</code> вместо <code>Future.all</code>.
</dd>
<dt>Используйте стандартные сокращения, и откажитесь от эзотерических</dt>
<dd>
Всем известны <code>ok</code>, <code>err</code> или <code>defn</code>,а вот <code>sfri</code> используется не так часто.
</dd>
<dt>Не используйте одни и теже имена для различных целей</dt>
<dd>Применяйте <code>val</code></dd>
<dt>Избегайте использования <code>`</code> для перегрузки зарезервированных имен.</dt>
<dd>Используйте <code>typ</code> вместо <code>`type</code>`</dd>
<dt>Используйте имени active для операций с побочными эффектами</dt>
<dd><code>user.activate()</code> вместо <code>user.setActive()</code></dd>
<dt>Используйте описательные имен для методов, которые возвращают значения</dt>
<dd><code>src.isDefined</code> вместо <code>src.defined</code></dd>
<dt>Не используйте у геттеров(getter) префикс <code>get</code></dt>
<dd>В соответствии с предыдущим правилом: лучше применять <code>site.count</code> вместо <code>site.getCount</code></dd>
<dt>Не используйте повторно имена, которые уже есть в пакете или в названии объекта</dt>
<dd>Предпочтительно:
<pre><code> object User {
   def get(id: Int): Option[User]
}</code></pre>вместо
<pre><code>object User {
   def getUser(id: Int): Option[User]
}</code></pre>Они являются избыточными при использовании: <code>User.getUser</code> дает не больше информации, чем <code>User.get</code>.
</dd>
</dl>

### Импортирование

<dl class="rules">
<dt>Располагайте строки импорта в алфавитном порядке</dt>
<dd>Так их проще определить визуально, и так проще для автоматизации.</dd>
<dt>Используйте фигурные скобки при импортировании нескольких имен из пакета</dt>
<dd><code>import com.twitter.concurrent.{Broker, Offer}</code></dd>
<dt>Используйте символ подчеркивания, когда импортируйте более 6 имен</dt>
<dd>например: <code>import com.twitter.concurrent._</code>
<br />Не применяйте его без оглядки, некоторые пакеты экспортируют слишком много имен</dd>
<dt>Когда используете коллекции, уточняйте имена при импортировании <code>scala.collection.immutable</code> и/или <code>scala.collection.mutable</code></dt>
<dd>Изменяемые и неизменяемые коллекции имеют двойные имена. Уточнение имен сделает очевидным для читателя какой вариант используется (например "<code>immutable.Map</code>")</dd>
<dt>Не используйте относительный импорт из других пакетов</dt>
<dd>Избегайте <pre><code>import com.twitter
import concurrent</code></pre> в пользу более одназначного <pre><code>import com.twitter.concurrent</code></pre></dd>
<dt>Располагайте строки импорта вверху файла</dt>
<dd>Читатель может обратится ко всем строкам импорта в одном месте</dd>
</dl>

### Фигурные скобки

Фигурные скобки используются для создания сложных выражений (они служат другим целям в "языковом модуле"), где значение соответствующего выражения является последним выражением в списке. Старайтесь не использовать скобки для простых выражений; пишите

	def square(х: Int) = х*х

.LP, вместо

	def square(х: Int) = {
 	  х * х
	}

.LP, хотя это может быть привлекательным, чтобы отличить тело метода синтаксически. Первый вариант имеет меньший беспорядок и его легче читать. <em>Избегайте синтаксических церемоний</em>, если это не уточняется.

### Сравнение с образцом

Используйте сравнение с образцом в определении функций, когда это необходимо;
Вместо

	list map { item =>
	  item match {
	    case Some(x) => x
	    case None => default
	  }
	}

.LP лучше написать так

	list map {
	  case Some(x) => x
	  case None => default
	}

.LP ясно, что элементы списка в настоящее время отображаются более ясно &mdash; дополнительно уточнять ничего не нужно.

### Комментарии

Используйте [ScalaDoc](https://wiki.scala-lang.org/display/SW/Scaladoc), чтобы предоставлять документацию по API, Используйте следующий стиль:

	/**
	 * ServiceBuilder builds services 
	 * ...
	 */
	 
.LP <em>вместо</em>стандартного стиля ScalaDoc:

	/** ServiceBuilder builds services
	 * ...
	 */

Не прибегайте к ASCII искусству или другим визуальным украшениям. Документируйте API, но не добавляйте ненужных комментариев. Если вы добавляете комментарии, чтобы объяснить поведение вашего кода, сначала спросите себя, может ли код быть переписан так, чтобы стало очевидным, что он делает. Предпочитайте "Очевидно, это работает" вместо "Это работает, очевидно" (цитата Энтони Хоара).

(прим. переводчика: "Есть два метода создания программного обеспечения. Один из них — сделать программу настолько простой, что, очевидно, в ней нет недостатков. И другой, сделать приложение настолько сложным, что в нем невидно явных недостатков." - [Энтони Хоар](http://ru.wikipedia.org/wiki/Хоар,_Чарльз_Энтони_Ричард) выдержка из лекции, [Премия Тьюринга](http://amturing.acm.org/award_winners/hoare_4622167.cfm))

## Типы и обобщенные типы

Основной целью системы типов является выявление ошибок программирования. Система типов эффективно обеспечивает определенную форму статической проверки, что позволяет нам получать определенный набор неизменных параметров о нашем коде, который компилятор может проверить. Система типов конечно обеспечивает и другие преимущества, но проверка ошибок является ее основной целью.

Наше использование системы типов должно отражать эту цель, но мы должны не забывать и о читателе: разумное использование типов может служить повышением ясности, быть заумным только запутывать остальных.

Мощная система типов в Scala является результатом общих усилий академических опытов и разработок (например, [Scala программирование на уровне системы типов] (http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/)).
В то время как это увлекательная академическая статья, эти методы редко находят полезное применение в реальном коде приложений. Их можно избегать.

### Комментарии о возвращаемом типе

В то время как Scala позволяет опускать их, такие комментарии обеспечивают хорошую документацию: это особенно важно для публичных методов. Там где возвращаемый тип метода очевиден, их можно опустить.

Это особенно важно при создании экземпляров объектов с миксинами(Mixins), так как компилятор Scala создает тип синглтон для них. Например, `make` в:

	trait Service
	def make() = new Service {
	  def getId = 123
	}

.LP <em>не</em> имеет возвращаемого типа <code>Service</code>, компилятор создает <code>Object with Service{def getId: Int}</code>. Вместо того, чтобы использовать явную аннотацию:

	def make(): Service = new Service{}

В настоящее время автор свободен смешивать множество трейтов(traits) без изменения общедоступного типа `make`, делая возможность легче управлять обратной совместимостью.

### Противоречие

Противоречие возникает, когда обобщеные типы объединены с выделением подтипов. Они определяют как выделение подтипов типа *contained* относится к выделению подтипов типа *container*. Потому что Scala имеется определенное соглашение по комментированию, авторы общих библиотек - особенно коллекций -
должны быть активными комментаторами. Такие комментарии важны для
удобства работы с общим кодом, но неверные комментарии могут быть опасны.

Инварианты - усовершенствованный, но необходимый компонент системы типов Scala,и должны использоваться широко (и правильно), поскольку это помогает приложению в выделении подтипов.

*Коллекции Immutable должны быть зависимыми(covariant)*. Методы, которые получают
contained тип должны быть "понижены"("downgrade") до соответствующей коллекции:
	
	trait Collection[+T] {
	  def add[U >: T](other: U): Collection[U]
	}

*Mutable коллекции должны быть неизменяемы(invariant)*. Зависимость обычно бессмыслена с изменяемыми(mutable) коллекциями. Будем считать

	trait HashSet[+T] {
	  def add[U >: T](item: U)
	}

.LP и следующую иерархию типов:

	trait Mammal
	trait Dog extends Mammal
	trait Cat extends Mammal

.LP Если у меня сейчас есть хеш-коллекцию из объектов Собака

	val dogs: HashSet[Dog]

.LP создаем хеш-коллекцию Млекопитающих и добавляем в колллекцию объект Кошка

	val mammals: HashSet[Mammal] = dogs
	mammals.add(new Cat{})

.LP Теперь эта хеш-коллекция не является коллекцией объектов Собака！

(прим. переводчика: Поддробнее о [ковариантности и контрвариантности](http://chabster.blogspot.com/2008/01/type-system-covariance-and.html))

<!--
  *	when to use abstract type members?
  *	show contravariance trick?
-->

### Псевдонимы типов

Используйте псевдонимы типов, когда они позволяют удобное именование или разъяснение цели, но не искажают типы, которые очевидны.

	() => Int

.LP данная запись более понятна чем

	type IntMaker = () => Int
	IntMaker

.LP так как это короче и используется общий тип, однако

	class ConcurrentPool[K, V] {
	  type Queue = ConcurrentLinkedQueue[V]
	  type Map   = ConcurrentHashMap[K, Queue]
	  ...
	}

.LP более полезно, так как это передает цель и улучшает краткость.

Не используйте разделение на подклассы, когда псевдоним делает тоже самое

	trait SocketFactory extends (SocketAddress => Socket)
	
.LP <code>SocketFactory</code> <em>это</em> функция которая создает <code>Socket</code>. Использование псевдонима

	type SocketFactory = SocketAddress => Socket

.LP более правильно. Теперь мы можем обеспечить функциональные идентификаторы для значений типа<code>SocketFactory</code>,а также использовать композицию функций:

	val addrToInet: SocketAddress => Long
	val inetToSocket: Long => Socket

	val factory: SocketFactory = addrToInet andThen inetToSocket

Псевдонимы типа связаны с именами, которые стоят выше в иерархии при помощи пакетных объектов:

	package com.twitter
	package object net {
	  type SocketFactory = (SocketAddress) => Socket
	}

Обратите внимание на то, что псевдонимы, это не новые типы - они эквивалентны
синтаксической замене типа новым именем.

### Неявные преобразования

Неявные преобразования являются мощной возможностью системы типов, но они должны использоваться экономно. Они усложняют правила преобразования и делают это достаточно трудно -- простым лексическим сравнением -- чтобы понять, что на самом деле происходит. Обычно неявные преобразования используются в следуюей ситуации:

* Расширение или добавление коллекций стиля программирования Scala
* Адаптация или расширение объекта (шаблон "pimp my library")
* Использование для *повышения безопасности типов*, предоставляя ограниченный набор данных
* Чтобы представить данные типа (typeclassing)
* Для `Манифестов`

Если действительно хотите использовать неявные преобразования, всегда спрашивайте себя, есть ли способ достигнуть той же цели без их помощи.

Не используйте неявные преобразования, чтобы сделать автоматическое преобразование между похожими типами данных (например, преобразование списка в поток); это лучше сделать явно, потому что у типов есть различная семантика, и читатель должен остерегаться подобных реализаций.

## Коллекции

У Scala есть универсальная, очень богатая, мощная, и прекрасно составленная библиотека коллекций; коллекции - высокоуровневые реализации и они представляют собой большой набор различный операций. Много действий с коллекциями и их преобразования могут быть выражены кратко и четко, но небрежное применение функций может привести к противоположному результату. Каждый Scala-программист должен прочитать [Сollections design document](http://www.scala-lang.org/docu/files/collections-api/collections.html);
он обеспечит большее понимание при работе с библиотекой коллекций Scala.

Всегда используйте самую простую коллекцию, которая соответствует вашим потребностям отребностям.

### Иерархия

Библиотека коллекций очень большая: в дополнение к сложной
иерархии - корнем которой является `Traversable[T]` - существуют
`immutable` и `mutable` варианты для большинства коллекций. Несмотря на сложность, на следующей диаграмме содержится важная
различия между `immutable` и `mutable` иерархиями

<img src="coll.png" style="margin-left: 3em;" />
.cmd
pic2graph -format png >coll.png <<EOF 
boxwid=1.0

.ft I
.ps +9

Iterable: [
	Box: box wid 1.5*boxwid
	"\s+2Iterable[T]\s-2" at Box
]

Seq: box "Seq[T]" with .n at Iterable.s + (-1.5, -0.5)
Set: box "Set[T]" with .n at Iterable.s + (0, -0.5)
Map: box "Map[T]" with .n at Iterable.s + (1.5, -0.5)

arrow from Iterable.s to Seq.ne
arrow from Iterable.s to Set.n
arrow from Iterable.s to Map.nw
EOF
.endcmd

.LP <code>Iterable[T]</code> - это любая коллекция, элементы которой могут быть итерированы, она имеет метод <code>iterator</code>(а также <code>foreach</code>).<code>Seq[T]</code>- это коллекция, элементы которой <em>отсортированы</em>,<code>Set[T]</code>- является аналогом математического множества (неупорядоченная коллекция уникальных элементов), и <code>Map[T]</code> - который представляет собой неотсортированный ассоциативный массив.

### Применение

* Предпочитительнее использовать immutable коллекции.* Они применимы в большинстве случаев, и делают программу проще и прозрачнее в понимании,а также потокобезопасной по умолчанию.

* Используйте `mutable` пространство имен явно.* Не импортируйте
`scala.collection.mutable._` и ссылку на `set`, лучше сделать так

	import scala.collections.mutable
	val set = mutable.Set()

.LP потому что становится чсно, что используется mutable вариант

* Используйте стандартный конструктор для коллекций.* Всякий раз, когда вам нужна упорядоченная последовательность (и не обязательно связаный список), используйте конструктор `Seq()`, и тому подобное:

	val seq = Seq(1, 2, 3)
	val set = Set(1, 2, 3)
	val map = Map(1 -> "one", 2 -> "two", 3 -> "three")

.LP Этот стиль отделяет семантику коллекции от ее реализации, позволяя библиотеке коллекций использовать наиболее подходящий тип: если вам нужна <code>Map</code>, не обязательно использовать <a href="http://ru.wikipedia.org/wiki/Красно-чёрное_дерево">Красно-черное дерево(Red-Black Tree)</a>. Кроме того, стандартные конструкторы будут часто использовать специализированные представления: например, <code>Map()</code> будет использовать объект с 3 полями для карт с 3 ключами(<a href="http://www.scala-lang.org/api/current/scala/collection/immutable/Map$$Map3.html"><code>Map3</code></a>).

В заключение к сказанному выше: в ваших собственных методах и конструкторах *старайтесь использовать самую универсальную коллекцию*. Обычно это сводится к одной из приведенных: `Iterable`, `Seq`, `Set`, или `Map`. Если ваш метод нуждается в последовательности, используйте `Seq[T]`, а не `List [T]`.

<!--
something about buffers for construction?
anything about streams?
-->

### Стиль

Функциональное программирование призывает к цепочечным преобразованиям
immutable коллекций для получения желаемого результата. Это часто
приводит к очень коротким решениям, но также может ввести в заблуждение
читателя - часто трудно понять намерения автора, или отслеживать все промежуточные результаты, которые подразумеваются. Например,
предположим, что мы хотим собрать голоса для разных языков программирования
из набора (язык, число голосов), показывая их, в порядке убывания числа голосов, мы могли бы написать:

	val votes = Seq(("scala", 1), ("java", 4), ("scala", 10), ("scala", 1), ("python", 10))
	val orderedVotes = votes
	  .groupBy(_._1)
	  .map { case (which, counts) => 
	    (which, counts.foldLeft(0)(_ + _._2))
	  }.toSeq
	  .sortBy(_._2)
	  .reverse

.LP это кратко и правильно, но почти любому читателю нужно время, чтобы восстановить в голове первоначальные намерения автора. Стратегия, которая призвана уточнить решение <em>использование промежуточных результатов и параметров</em>:

	val votesByLang = votes groupBy { case (lang, _) => lang }
	val sumByLang = votesByLang map { case (lang, counts) =>
	  val countsOnly = counts map { case (_, count) => count }
	  (lang, countsOnly.sum)
	}
	val orderedVotes = sumByLang.toSeq
	  .sortBy { case (_, count) => count }
	  .reverse

.LP код является почти столь же кратким, но гораздо более четко описывает происходящие превращения (именованные промежуточные значения), и структуры данных с которыми работает программа (именованные параметры). Если вы беспокоитесь о засорении пространства имен, применяя этот стиль, используйте группировку выражений с помощью <code>{}</code>:

	val orderedVotes = {
	  val votesByLang = ...
	  ...
	}


### 性能

高水準コレクションライブラリは、（高水準な構築物が一般的にそうであるように）性能の推測が難しい。コンピュータに直接指示するやり方、つまり命令型スタイルから遠ざかるほど、あるコード片が性能に与える影響を厳密に予測するのは困難になる。一方で、正確さを判断することは概して容易だし、読みやすさも向上する。Scalaの場合、Javaランタイムが事態をさらに複雑にしている。Scalaでは、ボクシング操作やアンボクシング操作がユーザから隠されており、性能やメモリ使用量の面で重大なペナルティを被ることがある。

低レベルの詳細に焦点を当てる前に、君のコレクションの使い方が適切かどうか確認しよう。また、データ構造に予期しない漸近的な複雑さがないか確かめよう。Scalaのさまざまなコレクションの複雑さについては、[こちら](http://www.scala-lang.org/docu/files/collections-api/collections_40.html)で述べられている。

性能最適化の第一法則は、君のアプリケーションが*なぜ*遅いのかを理解することだ。最適化を始める前に、君のアプリケーションをプロファイル^[[Yourkit](http://yourkit.com)は良いプロファイラだ。]してデータを取ろう。最初に注目するのは、回数の多いループや巨大なデータ構造だ。最適化への過度な取り組みは、たいてい無駄な努力に終わる。クヌースの「時期尚早な最適化は諸悪の根源("Premature optimisation is the root of all evil.")」という格言を思い出そう。

性能やメモリ使用効率の良さが要求される場面では、多くの場合、低レベルコレクションを使うのが妥当だ。巨大なシーケンスには、リストより配列を使おう（不変の`Vector`コレクションは、配列への参照透過なインタフェースを提供する）。また、性能が重要な場合は、シーケンスを直接生成せずにバッファを使おう。

### Javaコレクション

Javaコレクションとの相互運用のために、`scala.collection.JavaConverters`を使おう。`JavaConverters`は、暗黙変換を行う`asJava`メソッドと`asScala`メソッドを追加する。読み手を助けるために、これらの変換は明示的に行うようにしよう:

	import scala.collection.JavaConverters._
	
	val list: java.util.List[Int] = Seq(1,2,3,4).asJava
	val buffer: scala.collection.mutable.Buffer[Int] = list.asScala

## 並行性

現代のサービスは、サーバへの何万何十万もの同時操作を調整するため、高い並行性(concurrency)を備えている。そして、隠れた複雑性への対処は、堅固なシステムソフトウェアを記述する上で中心的なテーマだ。

*スレッド(thread)*は、並行性を表現する一つの手段だ。スレッドからは、OSによってスケジュールされる、独立したヒープ共有の実行コンテクストを利用できる。しかし、Javaにおいてスレッド生成はコストが高い。そのため、主にスレッドプールを使って、リソースとして管理する必要がある。これは、プログラマにとってさらなる複雑さを生み出す。また、アプリケーションロジックとそれが使用する潜在的なリソースを分離するのが難しくなり、結合度を高めてしまう。

この複雑さは、出力(fan-out)の大きいサービスを作成する際に、とりわけ明らかになる。それぞれの受信リクエストからは、システムのさらに別の階層に対する多数のリクエストが生じる。それらのシステムにおいて、スレッドプールは、各階層でのリクエストの割合によってバランスされるよう管理される必要がある。あるスレッドプールで管理に失敗すると、その影響は他のスレッドプールにも広がってしまう。

また、堅固なシステムは、タイムアウトとキャンセルについても検討する必要がある。どちらに対処するにも、さらなる「制御スレッド」の導入が必要で、そのことが問題をさらに複雑にする。ちなみに、もしスレッドのコストが安いなら、こうした問題は少なくなる。なぜなら、スレッドプールが必要とされず、タイムアウトしたスレッドを放棄することができ、追加のリソース管理も必要ないからだ。

このように、リソース管理はモジュール性を危うくするのだ。

### Future

Futureを使って並行性を管理しよう。Futureは、並行操作とリソース管理を疎結合にする。例えば、[Finagle][Finagle]は、並行操作をわずかなスレッド数で効率的に多重化する。Scalaには、軽量なクロージャリテラルの構文がある。だから、Futureは構文上の負担が小さく、ほとんどのプログラマが身に付けることができる。

Futureは、プログラマが並行計算を宣言的なスタイルで表現できるようにする。Futureは合成可能で、また計算の失敗を原則に基づいて処理できる。こうした性質から、Futureは関数型プログラミング言語にとても適しており、推奨されるスタイルだと確信している。

*生成したFutureを変換しよう。*Futureの変換を使うと、失敗の伝播やキャンセルの通知が行われることを保証できる。また、プログラマは、Javaメモリモデルの影響を検討する必要がなくなる。RPCを順番に10回発行して結果を表示するとき、注意深いプログラマでさえ、以下のように書いてしまうかもしれない:

	val p = new Promise[List[Result]]
	var results: List[Result] = Nil
	def collect() {
	  doRpc() onSuccess { result =>
	    results = result :: results
	    if (results.length < 10)
	      collect()
	    else
	      p.setValue(results)
	  } onFailure { t =>
	    p.setException(t)
	  }
	}

	collect()
	p onSuccess { results =>
	  printf("Got results %s\n", results.mkString(", "))
	}

RPCの失敗が確実に伝播するように、プログラマは、コードに制御フローをいくつも挿入する必要がある。さらに悪いことに、上記のコードは間違っている！ `results`を`volatile`として宣言していないので、各繰り返しにおいて、`results`が一つ前の値を保持していることを保証できない。Javaのメモリモデルは、油断ならない獣だ。しかし幸いにして、宣言的スタイルを使えば、これらの落とし穴を全て避けることができる:

	def collect(results: List[Result] = Nil): Future[List[Result]] =
	  doRpc() flatMap { result =>
	    if (results.length < 9)
	      collect(result :: results)
	    else
	      result :: results
	  }

	collect() onSuccess { results =>
	  printf("Got results %s\n", results.mkString(", "))
	}

シーケンスの操作に`flatMap`を使うと、処理が進むにつれて、リストの先頭に結果を追加できる。これは、関数型プログラミングの一般的なイディオムを、Futureに置き換えたものだ。これは正しく動作するだけでなく、必要な「おまじない」を少なくでき、間違いの元を減らすことができる。そして、読みやすい。

*Futureの結合子(combinator)を使おう。*`Future.select`や`Future.join`、そして`Future.collect`は、複数のFutureを結合して操作する際の一般的なパターンを体系化している。

### コレクション

並行コレクションの話題は、私見と、機微と、教義と、FUDに満ちている。それらは、多くの場合、実践において取るに足らない問題だ。いつでも、目的を果たす上で、最も単純で、最も退屈で、最も標準的なコレクションから始めよう。同期化コレクションでうまくいかないのが*分かる*前に、並行コレクションに手を伸ばしてはいけない。JVMは、同期を低コストで実現する洗練された機構を持っている。その有効性に、君は驚くはずだ。

不変(immutable)コレクションで目的を果たせるなら、それを使おう。不変コレクションは参照透過なので、並行コンテキストでの推論が簡単になる。不変コレクションの変更は、主に（`var`セルや`AtomicReference`が指す）現在の値への参照を更新することで行う。不変コレクションの変更には、注意が必要だ。他のスレッドへ不変コレクションを公開する場合、`AtomicReference`には再試行が必要だし、`var`変数は`volatile`として宣言しなければいけない。

可変(mutable)な並行コレクションは複雑な動作をするだけでなく、Javaメモリモデルの微妙な部分を利用する。だから、可変並行コレクションが更新を公開する方法など、暗黙的な挙動について理解しておこう。また、コレクションの合成には同期化コレクションを使おう。並行コレクションでは、`getOrElseUpdate`のような操作を正しく実装できないし、特に、合成コレクションの作成はエラーの温床だ。

<!--

use the stupid collections first, get fancy only when justified.

serialized? synchronized?

blah blah.

Async*?

-->


## 制御構造

関数型スタイルのプログラムは伝統的な制御構造が少なく済み、また、宣言型スタイルで書かれていると読みやすいことが多い。これは典型的には、ロジックをいくつかの小さなメソッドや関数に分解し、それらを互いに`match`式で貼り合わせることを意味する。また、関数型プログラムは、より式指向となる傾向がある。つまり、条件式のそれぞれの分岐は同じ型の値を計算し、`for (..) yield`で内包(comprehension)を計算する。また、再帰の利用が一般的だ。

### 再帰

*再帰表現を使うと、問題をしばしば簡潔に記述できる。*そしてコンパイラは、末尾呼び出しの最適化が適用できるコードを正規のループに置き換える（末尾最適化が適用されるかは`@tailrec`アノテーションで確認できる）。

ヒープの<span class="algo">fix-down</span>を、極めて標準的な命令型で実装したバージョンを検討しよう:

	def fixDown(heap: Array[T], m: Int, n: Int): Unit = {
	  var k: Int = m
	  while (n >= 2*k) {
	    var j = 2*k
	    if (j < n && heap(j) < heap(j + 1))
	      j += 1
	    if (heap(k) >= heap(j))
	      return
	    else {
	      swap(heap, k, j)
	      k = j
	    }
	  }
	}

このコードでは、whileループに入るたび、一つ前の反復で変更された状態を参照する。各変数の値は、どの分岐を取るかに依存する。また、正しい位置が見つかると、関数はループの中盤で`return`する（鋭い読者は、ダイクストラの["Go To Statement Considered Harmful"](http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html)に同様の議論があることに気づくと思う）。

（末尾）再帰による実装を検討してみよう^[[Finagle's heap
balancer](https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/loadbalancer/Heap.scala#L41)より]:

	@tailrec
	final def fixDown(heap: Array[T], i: Int, j: Int) {
	  if (j < i*2) return
	
	  val m = if (j == i*2 || heap(2*i) < heap(2*i+1)) 2*i else 2*i + 1
	  if (heap(m) < heap(i)) {
	    swap(heap, i, m)
	    fixDown(heap, m, j)
	  }
	}

.LP ここでは、すべての反復ははっきりと<em>白紙の状態で</em>開始される。また、参照セルが存在しないため、不変式(invariant)を数多く見出せる。このコードはより推論しやすいだけでなく、より読みやすい。それだけでなく、性能面のペナルティもない。コンパイラは、メソッドが末尾再帰なら、これを標準的な命令型のループへと変換するからだ。

（訳注: [エドガー・ダイクストラ](http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%89%E3%82%AC%E3%83%BC%E3%83%BB%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9)は、構造化プログラミングの提唱者。彼が執筆したエッセイ"Go To Statement Considered Harmful"は、「GOTO有害論」の端緒として有名。）

<!--
elaborate..
-->


### Return

前節では再帰を使うメリットを紹介したけど、だからといって命令型の構造は無価値だというわけじゃない。多くの場合、計算を早期に終了する方が、終点の可能性がある全ての位置に条件分岐を持つよりも適切だ。実際に、上記の`fixDown`は、ヒープの終端に達すると`return`によって早期に終了する。

`return`を使うと、分岐を減らして不変式(invariant)を定めることができる。これにより、入れ子が減ってコードを追いやすくなるだけでなく、後続のコードの正当性を論証しやすくなる（配列の範囲外をアクセスしないことを確認する場合とか）。これは、"ガード"節で特に有用だ:

	def compare(a: AnyRef, b: AnyRef): Int = {
	  if (a eq b)
	    return 0
	
	  val d = System.identityHashCode(a) compare System.identityHashCode(b)
	  if (d != 0)
	    return d
	    
	  // slow path..
	}

`return`を使って、コードを明快にして読みやすさを高めよう。ただし、命令型言語でのような使い方をしてはいけない。つまり、下記のように計算結果を返すために`return`を使うのは避けよう。

	def suffix(i: Int) = {
	  if      (i == 1) return "st"
	  else if (i == 2) return "nd"
	  else if (i == 3) return "rd"
	  else             return "th"
	}

.LP 代わりに下記のように書こう:

	def suffix(i: Int) =
	  if      (i == 1) "st"
	  else if (i == 2) "nd"
	  else if (i == 3) "rd"
	  else             "th"

.LP しかし、より優れているのは<code>match</code>式を使うことだ:

	def suffix(i: Int) = i match {
	  case 1 => "st"
	  case 2 => "nd"
	  case 3 => "rd"
	  case _ => "th"
	}

なお、クロージャの内部で`return`を使うと、目に見えないコストが発生する場合があるので注意しよう。

	seq foreach { elem =>
	  if (elem.isLast)
	    return
	  
	  // process...
	}
	
.LP このコードは、バイトコードでは例外の`throw`と`catch`として実装されるので、実行頻度の高いコードで使うと性能に影響を与える。

### `for`ループと内包

`for`を使うと、ループと集約を簡潔かつ自然に表現できる。`for`は、多数のシーケンスを平坦化(flatten)する場合に特に有用だ。`for`の構文は、内部的にはクロージャを割り当ててディスパッチしていることを覆い隠している。このため、予期しないコストが発生したり、予想外の挙動を示したりする。例えば、

	for (item <- container) {
	  if (item != 2) return
	}

.LP このコードは、`container`が計算を遅延させた場合にランタイムエラーが発生し、その結果として<code>return</code>が非局所的(nonlocal)に評価されてしまうことがある！

これらの理由から、コードを明瞭にするためである場合を除いて、`for`を使う代わりに、`foreach`や`flatMap`や`map`や`filter`を直接呼び出す方が良いことが多い。

（訳注1: Scalaのfor式は`foreach`、`flatMap`、`map`、`withFilter`を呼び出す糖衣構文で、ループ内の式は、コンパイル時にそれらのメソッドに渡される匿名関数に変換される。例えば、上記の例のfor式は、実際には

	container foreach { item =>
	  if (item != 2) return
	}

というコードとして実行される。原文では、最初からこのように記述することを推奨している。）

（訳注2: ネストした匿名関数での`return`式は、ランタイムエラーである`NonLocalReturnException`の`throw`と`catch`に変換される。この場合、`container`が遅延評価されると`return`式の挙動が意図しないものになる場合がある。詳細に興味がある場合は、[こちらの議論](https://github.com/scalajp/effectivescala/commit/8b448ef819e6d87d21fa78310b84fc72593b0226#commitcomment-996948)も参照してほしい。）

### `require`と`assert`

`require`と`assert`は、どちらも実行可能なドキュメントとして機能する。これらは、要求される不変条件(invariant)を型システムが表現できない状況で有用だ。`assert`は、コードが仮定する（内部あるいは外部の）*不変条件*を表現するために使われる。例えば、

	val stream = getClass.getResourceAsStream("someclassdata")
	assert(stream != null)

一方で、`require`はAPIの契約を表現するために使われる:

	def fib(n: Int) = {
	  require(n > 0)
	  ...
	}

## 関数型プログラミング

関数型プログラミングと一緒に用いる時に *値指向型* プログラミングは多くの恩恵を受ける。このスタイルはステートフルな変更よりも値の変換を強調する。得られるコードは参照透過(referentially transparent)であり、より強力な不変式(invariant)を提供し、さらに容易に推論することが可能になる。ケースクラス、パターンマッチ、構造化代入(destructuring-bind)、型推論、クロージャやメソッドの軽量な生成構文がこのツールになる。

### 代数的データ型としてのケースクラス

ケースクラス(case class)は代数的データ型(ADT)をエンコードする。パターンマッチと共に利用することで、ケースクラスは巨大なデータ構造をモデリングするのに役に立ち、強力な不変式を簡潔なコードとして提供する。パターンマッチの解析器は、さらに強力な静的保証を提供する包括的解析(exhaustivity analysis)を実装している。
ケースクラスと共に代数的データ型をエンコードする時、以下のパターンを使おう：

	sealed trait Tree[T]
	case class Node[T](left: Tree[T], right: Tree[T]) extends Tree[T]
	case class Leaf[T](value: T) extends Tree[T]

<code>Tree[T]</code>の型は<code>Node</code>と<code>Leaf</code>の2つのコンストラクタを持つ。<code>sealed</code>として型を宣言する事で、ソースファイルの外からコンストラクタを追加することを制限できるため、コンパイラに包括的解析を行わせることができる。

パターンマッチと一緒に利用することで、そのようなモデリングを簡潔かつ"明らかに正しい"コードにすることができる。

	def findMin[T <: Ordered[T]](tree: Tree[T]) = tree match {
	  case Node(left, right) => Seq(findMin(left), findMin(right)).min
	  case Leaf(value) => value
	}

ツリーのような再帰構造は代数的データ型の古典的なアプリケーションを構成する一方で、それらの有用な領域はかなり大きい。
代数的データ型でモデリングされた結合の分解は状態遷移(state machines)で頻繁に発生する。

### オプション

`Option`型は、空であること(`None`)、または満たされていること(`Some(value)`)を表すコンテナである。`null`に対する安全な代替手段を提供し、可能な限り如何なる時も利用されるべきである。`Option`型は、たかだかひとつの要素を持つコレクションであり、コレクションの操作で装飾される。利用しよう！

`Option`型は、無(`None`)か、有(`Some(Value)`)のどちらかを格納するコンテナである。nullの代わりに安全に使用でき、いつでも可能な限り使用されるべきである。
`Option`型は(たかだかひとつの一つの要素しかない)コレクションであり、集合の操作で利用できる。使うしかない!


以下のように書こう。

	var username: Option[String] = None
	...
	username = Some("foobar")

.LP 以下のようには書かない。

	var username: String = null
	...
	username = "foobar"

.LP 前者の方が安全な理由：<code>Option</code>型は<code>username</code>が空であることをチェックされなければならないことを静的に強要しているため。

`Option`の値の条件節の実行は`foreach`を使うべきである。以下の代わりに、

	if (opt.isDefined)
	  operate(opt.get)

.LP 以下のように書く

	opt foreach { value =>
	  operate(value)}

奇妙なスタイルに思えるかもしれないが、よりよい安全性を提供(例外を引き起こしうる`get`を呼んでいない)し、簡潔である。両方の選択肢が利用されうるなら、パターンマッチを使おう。

	opt match {
	  case Some(value) => operate(value)
	  case None => defaultAction()
	}

.LP しかし、もし値がない場合はデフォルト値で良いのであれば、<code>getOrElse</code>を使おう。

	operate(opt getOrElse defaultValue)

`Option`を多用しすぎてはいけない。もし、何か目的にあったデフォルト値、[*Null Object*](http://en.wikipedia.org/wiki/Null_Object_pattern)、があるなら、代わりにそれを使おう。

`Option`は、また、nullになり得る値を覆う扱いやすいコンストラクターと共に使おう。

	Option(getClass.getResourceAsStream("foo"))

.LP は、<code>Option[InputStream]</code> であり、<code>getResourceAsStream</code> が <code>null</code> を返す場合に、<code>None</code>  という値を返す。

### パターンマッチ

パターンマッチ (`x match { ...`) は、Scalaで書かれたコード内に広く使われている。パターンマッチは条件の実行および分解(destructuring)、ひとつの構成物へのキャストを合成する。うまく使うことで明快さと安全さの両方をより高めてくれる。

型ごとの処理を実装するためにパターンマッチを使う。

	obj match {
	  case str: String => ...
	  case addr: SocketAddress => ...

 
パターンマッチは、分解とあわせて利用された時(たとえば、ケースクラスをマッチングするとき)に最大限に役立つ
次の例のように書くべきではなく、

	animal match {
	  case dog: Dog => "dog (%s)".format(dog.breed)
	  case _ => animal.species
	  }

.LP 以下のように書く

	animal match {
	  case Dog(breed) => "dog (%s)".format(breed)
	  case other => other.species
	}


ただ、2つのコンストラクタ(`apply`) を利用する場合のみ、[カスタム抽出子] (http://www.scala-lang.org/node/112) を書く。
さもなければ不自然になる可能性がある。


デフォルト値がもっと意味を持つものであるとき、条件実行にパターンマッチを使わないようにする。
コレクションライブラリは通常`Option`を返すメソッドを提供する。次の例は避けよ。

	val x = list match {
	  case head :: _ => head
	  case Nil => default
	}

.LP なぜなら

	val x = list.headOption getOrElse default

.LP の方がより短く、目的が伝わりやすいからだ。

### 部分関数

Scala は 部分関数(`PartialFunction`) を定義するための構文上の簡略的記法を提供する。

	val pf: PartialFunction[Int, String] = {
	  case i if i%2 == 0 => "even"
	}

.LP また、これらは <code>orElse</code> と組み合わせられる。

	val tf: (Int => String) = pf orElse { case _ => "odd"}

	tf(1) == "odd"
	tf(2) == "even"

部分関数は多くの場面で起こり得るものであり，`PartialFunction` で効率的に符号化される。
メソッドの引数として利用する例：

	trait Publisher[T] {
	  def subscribe(f: PartialFunction[T, Unit])
	}

	val publisher: Publisher[Int] = ..
	publisher.subscribe {
	  case i if isPrime(i) => println("found prime", i)
	  case i if i%2 == 0 => count += 2
	  /* ignore the rest */
	}

.LP また状況によっては <code>Option</code> を返すような呼び出しがあるかもしれないが、

	// Attempt to classify the the throwable for logging.
	type Classifier = Throwable => Option[java.util.logging.Level]

.LP これも、<code>PartialFunction</code>を使って表現する方がよいだろう。

	type Classifier = PartialFunction[Throwable, java.util.Logging.Level]

.LP それはより優れた構成可能性(composability)につながるからだ。

	val classifier1: Classifier
	val classifier2: Classifier

	val classifier = classifier1 orElse classifier2 orElse { _ => java.util.Logging.Level.FINEST }


### Destructuring bindings

Destructuring bindによる値代入は、パターンマッチに関連している。
それらは同じメカニズムを利用しているが、(例外の可能性を許容しないために)正確にひとつの選択肢があるときだけ適用できる。
Destructuring bindは特にタプルやケースクラスで有用である。

	val tuple = ('a', 1)
	val (char, digit) = tuple

	val tweet = Tweet("just tweeting", Time.now)
	val Tweet(text, timestamp) = tweet

（訳注: Destructuring bindは、「構造化代入」や「分配束縛」等の訳がある。詳細については、[こちらの議論](https://github.com/scalajp/effectivescala/issues/4)を参照してほしい。）

### 遅延評価

Scala のフィールドは、`val` が `lazy` プレフィックスと共に使われた時は *必要になったときに* 計算されるようになる。
なぜなら、(フィールドを `private[this]` にしない限りは)フィールドとメソッドは Scala では等価だからである。

	lazy val field = computation()

.LP は、(概して) 簡略的記法で、

	var _theField = None
	def field = if (_theField.isDefined) _theField.get else {
	  _theField = Some(computation())
	  _theField.get
	}

.LP すなわち、結果を演算し記憶する。この目的のために遅延フィールドを使うようにし、しかし、遅延さが意味を持って(by semantics)要求されるときには遅延評価を使うことを避ける。
このような場合には、コストモデルを明確にし、副作用をより正確に制御するために明示的であることがよりよい。

遅延フィールドはスレッドセーフである。

### 名前呼び出し

メソッドの引数は名前によって特定されるかもしれない、その意味するところは
パラメータは値に紐付くのではなくて、繰り返し実行されうる *演算* に対して紐付くということである。
この機能は気をつけて適用されなければならない。値渡しの文脈を期待している呼び出し側は驚くであろう。
この機能は構文的に自然な DSL を構築するためにある。-- 新しい制御構造は特に、かなりネイティブな言語機能に見えるように作ることができる

名前呼び出しは、そのような制御構造のためだけに使うことだ。そこでは、渡されてくるものは、
思いも寄らない演算結果より"ブロック"であるということが、呼び出し側に明らかである。
名前呼び出しは、最後の引数リストの最後の位置にある引数にだけ使うことだ。
名前呼び出しを使うときは、呼び出し側にその引数が名前呼び出しであることが明確に伝わるようにメソッドには名称をつけることを確実におこなう。

値を複数回演算させたいとき、また特にその演算が副作用を持つとき、陽関数(explicit functions)を使う。


	class SSLConnector(mkEngine: () => SSLEngine)

.LP 目的は明らかに残しつつ、呼び出し元が驚くことがなくなる。

### `flatMap`

`map` と `flatten` の合成である `flatMap` は、鋭敏な力と素晴らしい実用性を持ち、特別な注目を浴びるに値する。
その同類である `map` のように、`Future` や `Option` といった非伝統的なコレクションにおいて、頻繁に利用できる。
その振る舞いは、`Container[A]`といったシグネチャによって明らかになる。
 
	flatMap[B](f: A => Container[B]): Container[B]

.LP <code>flatMap</code> は、<em>新しい</em> コレクションを生成するコレクションの各要素に対して関数 <code>f</code> を呼び出し、それら(のすべて)は、
フラットな結果になる。例えば、次のコードは、同じ文字が繰り返されない2文字からなる文字列の順列をすべて取得する。
 
	val chars = 'a' to 'z'
	val perms = chars flatMap { a =>
	  chars flatMap { b =>
	    if (a != b) Seq("%c%c".format(a, b))
	    else Seq()
	  }
	}

.LP これは、より簡潔な for による包含に等価である。(それは、&mdash; 荒くまとめるなら &mdash; 上記のためのシンタックスシュガーである)
 
	val perms = for {
	  a <- chars
	  b <- chars
	  if a != b
	} yield "%c%c".format(a, b)

`flatMap` は、(Optionの連鎖(chain of options)を畳み込んでひとつにするときなど) `Option` を扱うときに頻繁に役に立つ。
 
	val host: Option[String] = ..
	val port: Option[Int] = ..
	
	val addr: Option[InetSocketAddress] =
	  host flatMap { h =>
	    port map { p =>
	      new InetSocketAddress(h, p)
	    }
	  }

.LP これも、<code>for</code> を使えばもっと簡潔に記述できる。
 
	val addr: Option[InetSocketAddress] = for {
	  h <- host
	  p <- port
	} yield new InetSocketAddress(h, p)

`Future` における `flatMap` の利用については、<a href="#Twitter's%20standard%20libraries-Futures">futures section</a> で議論されている。

## オブジェクト指向プログラミング

Scala の広大な広がりの大部分はオブジェクト機構にある。Scala は、 *すべての値* がオブジェクトであるという意味で、 *純粋な* 言語である。プリミティブな型と混合型の間に違いはない。 Scala はミックスインの機能もあり、静的型チェックの利益をすべて享受しつつ、もっと直行して別々なモジュールをコンパイル時に柔軟に一緒に組立てられる。

ミックスイン機構の背景ある動機は、伝統的な依存性注入を不要にすることである。その"コンポーネントスタイル"プログラミングの極致は、 [Cake
パターン](http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di/) である。

（訳注: 上記のCakeパターンに関するエントリは、@eed3si9n氏が[日本語訳](http://eed3si9n.com/ja/real-world-scala-dependency-injection-di)を提供している。）

### 依存性注入

しかし、我々の場合、Scala それ自身が、"クラシックな"（コンストラクタによる）依存性注入(dependency injection)の多くの構文上のオーバーヘッドを排除してくれるため、むしろ、使うようにしている。それはより明快であり、依存性は(コンストラクタの)型でまだエンコードされ、クラスの組立は構文上、そよ風並に些細な作業に過ぎない。それは退屈でシンプルだが動作する。*プログラムのモジュール化のために依存性注入を使うことだ*。特に、*継承より合成を選択することだ* 。これにより、よりモジュール化が進みテスト可能なプログラムになる。継承が必要な状況に遭遇した際には自分自身に問うのだ：もし、言語が継承をサポートしていなかったら、どのように構造化するだろう、と。この答えは強いることができるかもしれない。

依存性注入は典型的にはトレイトを利用する。

     trait TweetStream {
       def subscribe(f: Tweet => Unit)
     }
     class HosebirdStream extends TweetStream ...
     class FileStream extends TweetStream ..

     class TweetCounter(stream: TweetStream) {
       stream.subscribe { tweet => count += 1 }
     }

*ファクトリー* (オブジェクトを生成するオブジェクト)を注入することは一般的である。以下のような場合には、特化したファクトリー型よりはシンプルな関数の利用を好むようにする。

     class FilteredTweetCounter(mkStream: Filter => TweetStream) {
       mkStream(PublicTweets).subscribe { tweet => publicCount += 1 }
       mkStream(DMs).subscribe { tweet => dmCount += 1 }
     }

### トレイト

依存性注入は、一般的な *インターフェイス* の利用や、トレイト(trait)での共通コードの実装を妨げるものでは全くない。むしろ全く反対であり、トレイトの利用は正確には次の理由で強く推奨されている：複数のインターフェイス(トレイト)は、具象クラスで実装されるかもしれないし、共通コードはすべてのそれらのクラス群に横断的に再利用されるかもしれない。

トレイトは短くて直交するように保つことだ。分割可能な機能をひとつのトレイトの塊にしてしまってはいけない。最も小さな関連するアイデアだけを一緒にすることを考えるようにする。たとえば、IOをする何かを想像してみるといい。

     trait IOer {
       def write(bytes: Array[Byte])
       def read(n: Int): Array[Byte]
     }

.LP これを２つの振る舞いに分離する。

     trait Reader {
       def read(n: Int): Array[Byte]
     }
     trait Writer {
       def write(bytes: Array[Byte])
     }

.LP そして、もともと<code>IOer</code> だったこれらを、 <code>new Reader with Writer</code>&hellip; のようにミックスする。インターフェイスの最小化は、よりよい直交性とよりよりモジュール化につながる。

### 可視性

Scala は非常に表現豊かな可視性を制御する修飾子を持つ。修飾子は、何を *公開API* として構成するかを定義するのに重要である。公開APIは限定されるべきであり、それにより利用者は不注意に実装の詳細に依存することはなくなり、また、作者のAPIを変更する力を制限する。このことは、良いモジュール性にとって決定的に重要である。ルールとして、公開APIを拡張することは、彼らと契約するよりも全然簡単である。貧相なアノテーションは、君のコードの後方バイナリ互換性を汚すこともできるようにもなる。


#### `private[this]`

`private` にしたクラスメンバーは、

     private val x: Int = ...

.LP そのクラスの(サブクラスは含まない)すべての<em>インスタンス</em>から見える。殆どの場合、<code>private[this]</code>としたいだろう。

     private[this] val: Int = ..

.LP これで特定のインスタンスのみに可視性は制限された。Scala コンパイラーは、<code>private[this]</code> を(静的に定義されたクラスにアクセスが限られるから)シンプルなフィールドアクセッサに変換することもでき、それは時々、性能を最適化することに寄与する。

#### シングルトンクラス型

Scala では、シングルトンクラス型を生成することは一般的である。例えば、

     def foo() = new Foo with Bar with Baz {
       ...
     }

.LP このような状況では、戻り型を宣言することで可視性は限定される。

     def foo(): Foo with Bar = new Foo with Bar with Baz {
       ...
     }

.LP <code>foo()</code> の呼び出し側は、戻り値のインスタンスの限定されたビュー(<code>Foo with Bar</code>) を参照する。

### 構造的部分型

構造的部分型(structural type)は通常は使わない。構造的部分型は、便利で強力な機能であるが、残念なことに JVM 上では効率的な実装手段はない。しかし、ある運命のいたずらともいうべき実装によって、リフレクションをするためのとても良い速記法を提供する。

     val obj: AnyRef
     obj.asInstanceOf[{def close()}].close()

（訳注: "structural typing"を直訳すると「構造的な型付け」だが、Scalaの文脈では「構造的部分型(structural subtyping)」と同じ意味だと考えて良い。この用語の背景については、[@kmizu氏による解説](https://github.com/scalajp/effectivescala/pull/1#r455268)を参照して欲しい。）

## ガベージコレクション

我々は、運用時にガベージコレクションのチューニングに多くの時間を費やす。
ガベージコレクションの考慮事項はかなりJavaのそれに似ているが、典型的な Scala コードの場合は 典型的な Java コードより多くの(生存時間の短い)ガベージを生成する。これは関数スタイルの副作用なのである。HotSpot の世代別ガベージコレクションは、ほとんどの環境では生存時間の短いガベージを効果的に解放するので、概してこれは問題にならない。

GCの性能問題に取り組む前に、Attila が発表した我々のGCチューニングに関する経験のいくつかに関する[プレゼンテーション](http://www.infoq.com/presentations/JVM-Performance-Tuning-twitter)を見て欲しい。


Scala 固有で、GC問題を軽減する唯一のツールは、ガベージの生成をより少なくすることである。しかし、データなしで行動してはならない！もし、明らかに悪化させる何かをしているわけではないのであれば、我々の提供する [heapster](https://github.com/mariusaeriksen/heapster) や
[gcprof](https://github.com/twitter/jvmgcprof) を含む、Java の様々なプロファイルツールを使うことだ。

## Java 互換性

我々は、Javaで利用されるようなコードを Scala で書くとき、Javaでの使い方を慣用的に残して良いものか確かめるようにしている。大体は余計な努力は必要ない。クラス群と実装を含まないトレイトはJava に正確に等価に対応される。しかし、時々、別に Java API を提供する必要がある。あなたのライブラリのJava API の感じをつかむ良い方法は単体テストをJavaで書くことである(ただコンパイルが通れば良い)。この点については Scala コンパイラーは不安定であるのだが、このテストによって、あなたのライブラリの Java 視点は安定さを維持できる。

実装を含むトレイトは直接 Java から利用できない。代わりに抽象クラスをトレイトと共に拡張する必要がある。

     // 直接 Java からは利用できない
     trait Animal {
       def eat(other: Animal)
       def eatMany(animals: Seq[Animal) = animals foreach(eat(_))
     }

     // しかし、これなら利用できる
     abstract class JavaAnimal extends Animal

## Twitterの標準ライブラリ

Twitterにおいて、最も重要な標準ライブラリは[Util](http://github.com/twitter/util)と[Finagle](https://github.com/twitter/finagle)だ。Utilは、ScalaやJavaの標準ライブラリの拡張という位置付けで、それらに欠けている機能やより適切な実装を提供する。Finagleは、TwitterのRPCシステムで、分散システムの構成要素の中核だ。

### Future

Futureについては、<a href="#並行性">並行性</a>の章でも少し<a href="#並行性-Future">議論した</a>。Futureは、非同期処理の連係において重要な機構で、TwitterのコードベースやFinagleのコアで広く使われている。Futureは、並行イベントの合成(composition)を可能にすると共に、高度な並行操作についての判断を単純化する。また、Futureを使うと、並行操作をJVM上で極めて効率的に実装できる。

ネットワーク入出力やディスク入出力等の操作は、基本的にスレッドの実行を一時停止する可能性がある。TwitterのFutureは*非同期的*なので、ブロックする操作(blocking operation)は、操作結果に対するFutureを提供するシステム自身によって処理されなければいけない。Finagleは、ネットワーク入出力のためのそうしたシステムを提供する。

Futureは、単純明白だ。Futureは、まだ完了していない計算の結果に対する*約束(promise)*を保持する、単純なコンテナ（プレースホルダ）だ。当然、計算は失敗することがあるので、このこともコード化する必要がある。Futureは三つの状態、すなわち*保留(pending)*、*失敗(failed)*、*完了(completed)*のうち、きっかり一つの状態を取ることができる。

<div class="explainer">
<h3>余談: <em>合成(composition)</em></h3>
<p>もう一度確認すると、合成とは、単純なコンポーネントを結合してより複雑なコンポーネントにすることだ。合成の標準的な例は、関数合成だ。関数<em>f</em>と<em>g</em>が与えられたとき、合成関数<em>(g&#8728;f)(x) = g(f(x))</em>は、まず<em>x</em>を<em>f</em>に適用し、その結果を<em>g</em>に適用した結果だ。この合成関数をScalaで書くと:</p>

<pre><code>val f = (i: Int) => i.toString
val g = (s: String) => s+s+s
val h = g compose f  // : Int => String
	
scala> h(123)
res0: java.lang.String = 123123123</code></pre>

.LP この関数<em>h</em>は合成関数で、<em>f</em>と<em>g</em>の双方を所定の方法で結合した<em>新しい</em>関数だ。
</div>

Futureは、ゼロ個あるいは一個の要素を持つコンテナであり、コレクションの一種だ。Futureは、`map`や`filter`や`foreach`といった、標準コレクションのメソッドを持つ。Futureの値は遅延されるので、必然的にこれらのコレクションメソッドを適用した結果もまた遅延される。

	val result: Future[Int]
	val resultStr: Future[String] = result map { i => i.toString }

.LP 関数<code>{ i => i.toString }</code>は、Int値が利用可能になるまで呼び出されない。また、変換されたコレクションである<code>resultStr</code>も、その時まで保留状態(pending state)になる。

リストは平坦化(flatten)できる;

	val listOfList: List[List[Int]] = ..
	val list: List[Int] = listOfList.flatten

.LP また、平坦化はFutureにおいても意味をなす:

	val futureOfFuture: Future[Future[Int]] = ..
	val future: Future[Int] = futureOfFuture.flatten

.LP Futureの<code>flatten</code>の実装は、直ちにFutureを返す。Futureは遅延するので、<code>flatten</code>が返すFutureは、外側のFuture(<code><b>Future[</b>Future[Int]<b>]</b></code>)の完了と、その後に内側のFuture(<code>Future[<b>Future[Int]</b>]</code>)の完了を待つ結果だ。また、外側のFutureが失敗したら、平坦化されたFutureも失敗する必要がある。

Futureは、Listと同様に`flatMap`を定義している。`Future[A]`は、そのシグネチャを以下のように定義する。

	flatMap[B](f: A => Future[B]): Future[B]
	
.LP `flatMap`は、<code>map</code>と<code>flatten</code>の組み合わせのようなもので、以下のように実装できる:

	def flatMap[B](f: A => Future[B]): Future[B] = {
	  val mapped: Future[Future[B]] = this map f
	  val flattened: Future[B] = mapped.flatten
	  flattened
	}

これは、強力な組み合わせだ！ `flatMap`によって、二番目のFutureを最初のFutureの結果に基づいて計算する、順番に並べられた二つのFutureの結果である新しいFutureを定義できる。ユーザ(ID)を認証するために、二つのRPCを実行する必要がある場合を想像してほしい。この場合、合成された操作を以下の方法で定義できる:

	def getUser(id: Int): Future[User]
	def authenticate(user: User): Future[Boolean]
	
	def isIdAuthed(id: Int): Future[Boolean] = 
	  getUser(id) flatMap { user => authenticate(user) }

.LP この種の結合のもう一つの恩恵は、エラー処理が組み込まれていることだ。<code>getUser(..)</code>か<code>authenticate(..)</code>が追加でエラー処理をしない限り、<code>isAuthed(..)</code>が返すFutureは失敗するだろう。

#### スタイル

Futureのコールバックメソッドである`respond`や`onSuccess`、`onFailure`、`ensure`は、その親に*連鎖した(chained)*新たなFutureを返す。このFutureは、その親が完了して初めて完了することが保証されている。このパターンを実現するには、例えば以下のようにする。

	acquireResource()
	future onSuccess { value =>
	  computeSomething(value)
	} ensure {
	  freeResource()
	}

.LP このとき<code>freeResource()</code>は、<code>computeSomething</code>の後にのみ実行されることが保証される。これにより、ネイティブな<code>try .. finally</code>パターンのエミュレートが可能になる。

`foreach`の代わりに`onSuccess`を使おう。`onSuccess`の方が`onFailure`と対称を成して目的をより良く表せるし、連鎖も可能になる。

なるべく、`Promise`インスタンスを直接作らないようにしよう。ほぼ全てのタスクは、定義済みの結合子を使って実現できる。結合子は、エラーやキャンセルが伝播することを保証すると共に、一般的に*データフロー方式*でのプログラミングを促進する。データフロー方式を使うと、大抵、<a href="#並行性-Future">同期化や`volatile`宣言が不要になる</a>。

末尾再帰方式で書かれたコードは、スタック空間のリークを引き起こさないので、データフロー方式を使ってループを効率的に実装できる:

	case class Node(parent: Option[Node], ...)
	def getNode(id: Int): Future[Node] = ...

	def getHierarchy(id: Int, nodes: List[Node] = Nil): Future[Node] =
	  getNode(id) flatMap {
	    case n@Node(Some(parent), ..) => getHierarchy(parent, n :: nodes)
	    case n => Future.value((n :: nodes).reverse)
	  }

`Future`は、数多くの有用なメソッドを定義している。`Future.value()`や`Future.exception()`を使うと、事前に結果が満たされたFutureを作れる。`Future.collect()`や`Future.join()`、`Future.select()`は、複数のFutureを一つにまとめる結合子を提供する（ie. scatter-gather操作のgather部分）。

#### キャンセル

Futureは、弱いキャンセルを実装している。`Future#cancel`の呼び出しは、計算を直ちに終了させるのではなく、レベルトリガ方式の*シグナル*を伝播する。最終的にFutureを満たすのがいずれの処理であっても、シグナルに問い合わせる(query)ことができる。キャンセルは、値から反対方向へ伝播する。つまり、消費者(consumer)がセットしたキャンセルのシグナルは、対応する生産者(producer)へと伝播する。生産者は`Promise`にある`onCancellation`を使って、シグナルに応じて作動するリスナーを指定する。

つまり、キャンセルの動作は生産者に依存し、デフォルトの実装は存在しない。*キャンセルはヒントに過ぎない。*

#### Local

Utilライブラリの[`Local`](https://github.com/twitter/util/blob/master/util-core/src/main/scala/com/twitter/util/Local.scala#L40)は、ローカルから特定のFutureのディスパッチツリーへの参照セルを提供する。`Local`の値をセットすると、同じスレッド内のFutureによって遅延されるあらゆる計算が、この値を利用できるようになる。これらはスレッドローカルに似ているけど、そのスコープはJavaのスレッドでなく、"Futureスレッド"のツリーだ。

	trait User {
	  def name: String
	  def incrCost(points: Int)
	}
	val user = new Local[User]

	...

	user() = currentUser
	rpc() ensure {
	  user().incrCost(10)
	}

.LP ここで、<code>ensure</code>ブロックの中の<code>user()</code>は、コールバックが追加された時点での<code>user</code>(Local)の値を参照する。

スレッドローカルと同様に`Local`は非常に便利なこともあるが、ほとんどの場合は避けるべきだ。データを明示的に渡して回るのは、たとえそうした方が負担が少なくても、問題を十分に解決できないことを確認しよう。

Localは、RPCのトレースを介したスレッド管理や、モニターの伝播、Futureコールバックのための"スタックトレース"の作成など、*とても*一般的な関心事(concern)を実現する際に、その他の解決策ではユーザに過度な負担がある場合、コアとなるライブラリにおいて効果的に使われる。Localは、その他のほとんどの場面では不適切だ。

### OfferとBroker

並行システムは非常に複雑だ。それは、共有データやリソースへのアクセスを協調させる必要があるからだ。[Actor](http://www.scala-lang.org/api/current/scala/actors/Actor.html)は、単純化の一つの戦略を提起している。Actorはシーケンシャルなプロセスで、それぞれが自分自身の状態やリソースを保持している。そして、データは、他のActorとのメッセージングによって共有される。共有データは、Actor間で通信する必要がある。

OfferとBrokerは、これに基づいて、三つの重要な考え方を取り入れている。一つ目、通信チャネル(Broker)は第一級(first class)だ。すなわち、Actorに直接メッセージを送るのではなく、Broker経由で送信する。二つ目、OfferやBrokerは同期化メカニズムであり、通信することは同期化することだ。これは、Brokerが協調メカニズムとして使えることを意味する。プロセス`a`がプロセス`b`にメッセージを送信したとき、`a`と`b`の両方とも、システムの状態について合意する。三つ目、通信は*選択的に*実行できる。一つのプロセスは、いくつかの異なる通信を提案でき、それらのうち、ただ一つが有効になる。

一般的な（他の合成と同様の）やり方で選択的な通信をサポートするには、通信行為(act of communicating)から通信の記述(description of a communication)を分離する必要がある。これをやるのが`Offer`だ。Offerは通信を記述する永続的な値であり、通信を（Offerに従って）実行するには、`sync()`メソッドによって同期化する。

	trait Offer[T] {
	  def sync(): Future[T]
	}

.LP `sync()`メソッドは、通信が行われた時にやり取りされた値を生成する<code>Future[T]</code>を返す。

`Broker`は、Offerを介して値のやり取りを協調する。Brokerは通信のチャネルだ:

	trait Broker[T] {
	  def send(msg: T): Offer[Unit]
	  val recv: Offer[T]
	}

.LP そして、二つのOfferを生成するとき、

	val b: Broker[Int]
	val sendOf = b.send(1)
	val recvOf = b.recv

.LP <code>sendOf</code>と<code>recvOf</code>はどちらも同期化されており、

	// In process 1:
	sendOf.sync()

	// In process 2:
	recvOf.sync()

.LP どちらのOfferも有効になり、<code>1</code>の値がやり取りされる。

選択的な通信は、いくつかのOfferを`Offer.choose`で結合することにより実行される。

	def choose[T](ofs: Offer[T]*): Offer[T]

.LP は、同期化すると<code>ofs</code>のうち、最初に利用可能になった唯一つのOfferを有効とする、新しいOfferを生成する。いくつかが即座に利用可能になった場合は、有効になる`Offer`はランダムに選ばれる。

`Offer`オブジェクトは、一個限りのOfferをいくつも持っており、BrokerからのOfferを組み立てるために使用される。

	Offer.timeout(duration): Offer[Unit]

.LP は、与えられた期間の後に起動するOfferだ。<code>Offer.never</code>は、決して有効にならない。また、<code>Offer.const(value)</code>は、与えられた値が直ちに有効になる。選択的な通信を用いて合成するのにも有用だ。例えば、送信操作でタイムアウトを適用するときは:

	Offer.choose(
	  Offer.timeout(10.seconds),
	  broker.send("my value")
	).sync()

OfferとBrokerを使う方法と、[SynchronousQueue](http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/SynchronousQueue.html)を比べてみたくなるかもしれないが、両者には微妙だが重要な違いがある。Offerは組み立てることができるが、SynchronousQueueのようなキューでは、とてもそんなことはできない。例えば、Brokerで表される一連のキューを考えると:

	val q0 = new Broker[Int]
	val q1 = new Broker[Int]
	val q2 = new Broker[Int]
	
.LP ここで、読み込みのための結合されたキューを作ってみると:

	val anyq: Offer[Int] = Offer.choose(q0.recv, q1.recv, q2.recv)
	
.LP <code>anyq</code>はOfferで、最初に利用可能になったキューから読み込む。ここで、<code>anyq</code>はやはり同期的であり、内部にあるキューの動作を利用できる。こうした合成は、キューを使う方法ではとても不可能だ。
	
#### 例: 簡単なコネクションプール

コネクションプールはネットワークアプリケーションでは一般的なもので、たいていは実装がとても難しい。例えば、個々のクライアントは異なるレイテンシを要求するため、多くの場合、プールからの取得にタイムアウトを持つことが望ましい。プールは、原理的には単純だ。コネクションのキューを保持し、待機クライアント(waiter)が入ってきたら要求を満たしてやる。従来の同期化プリミティブでは、典型的には二つのキューを保持する。一つはwaiterで、コネクション(connection)がない時に使われる。もう一つはconnectionで、これは待機クライアント(waiter)がない時に使われる。

OfferとBrokerを使うと、これをとても自然に表現できる:

	class Pool(conns: Seq[Conn]) {
	  private[this] val waiters = new Broker[Conn]
	  private[this] val returnConn = new Broker[Conn]

	  val get: Offer[Conn] = waiters.recv
	  def put(c: Conn) { returnConn ! c }
	
	  private[this] def loop(connq: Queue[Conn]) {
	    Offer.choose(
	      if (connq.isEmpty) Offer.never else {
	        val (head, rest) = connq.dequeue
	        waiters.send(head) { _ => loop(rest) }
	      },
	      returnConn.recv { c => loop(connq enqueue c) }
	    ).sync()
	  }
	
	  loop(Queue.empty ++ conns)
	}

`loop`は、返却されたコネクションを持つことを常にオファー(offer)し、キューが空でない時のみ送信をオファーする。永続的なキューを使うことで、推論をより単純にできる。プールに対するインタフェースもOfferを介しているから、もし呼び出し側がタイムアウトを適用したいなら、コンビネータを使うことで可能だ:

	val conn: Future[Option[Conn]] = Offer.choose(
	  pool.get { conn => Some(conn) },
	  Offer.timeout(1.second) { _ => None }
	).sync()

タイムアウトの実装に余計な簿記は必要とされない。これは、Offerの動作によるものだ: もし`Offer.timeout`が選択されたら、もはやプールからの受信をオファーしない。つまり、プールと呼び出し側がそれぞれ、Brokerである`waiters`上で送信と受信を同時に合意することはない。

#### 例: エラトステネスの篩

並行プログラムを、同期的に通信する一連のシーケンシャルなプロセスとして構築するのは、多くの場合で有用だし、時としてプログラムを非常に単純化できる。OfferとBrokerは、これを単純化しかつ統一化する手段を提供する。実際、それらのアプリケーションは、人が"古典的な"並行性の問題だとみなすかもしれないことを乗り越える。（OfferやBrokerを用いた）並行プログラミングは、サブルーチンやクラス、モジュールと同じように、有用な*構造化*ツールだ。これは、制約充足問題(Constraint Satisfaction Problem; CSP)からのもう一つの重要なアイデアだ。

この一つの例は[エラトステネスの篩](http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9)で、整数ストリームに対するフィルタの連続的な適用として構造化できる。まず、整数の生成源が必要だ:

	def integers(from: Int): Offer[Int] = {
	  val b = new Broker[Int]
	  def gen(n: Int): Unit = b.send(n).sync() ensure gen(n + 1)
	  gen(from)
	  b.recv
	}

.LP <code>integers(n)</code>は、<code>n</code>から始まる全ての連続した整数の単純なOfferだ。次に、フィルタが必要だ:

	def filter(in: Offer[Int], prime: Int): Offer[Int] = {
	  val b = new Broker[Int]
	  def loop() {
	    in.sync() onSuccess { i =>
	      if (i % prime != 0)
	        b.send(i).sync() ensure loop()
	      else
	        loop()
	    }
	  }
	  loop()
	
	  b.recv
	}

.LP <code>filter(in, p)</code>は、<code>in</code>から素数<code>p</code>の倍数を取り除くOfferを返す。最後に、篩(sieve)を定義する:

	def sieve = {
	  val b = new Broker[Int]
	  def loop(of: Offer[Int]) {
	    for (prime <- of.sync(); _ <- b.send(prime).sync())
	      loop(filter(of, prime))
	  }
	  loop(integers(2))
	  b.recv
	}

.LP <code>loop()</code>の動作は単純だ: <code>of</code>から次の素数を読み取った後、この素数を除外した<code>of</code>にフィルタを適用する。<code>loop</code>が再帰するにつれて連続した素数がフィルタされ、篩が手に入る。今や、我々は最初から10000個の素数を出力できる:

	val primes = sieve
	0 until 10000 foreach { _ =>
	  println(primes.sync()())
	}

このアプローチは、単純かつ直行的なコンポーネントへと構造化できることに加えて、篩をストリームとして扱える。君は、興味がある素数の集合を演繹的に計算したり、さらにモジュラリティを拡張したりする必要がない。

## 謝辞

本レッスンは、Twitter社のScalaコミュニティによるものだ。私は、誠実な記録者でありたい。

Blake MathenyとNick Kallen、Steve Gury、そしてRaghavendra Prabhuには、とても有益な助言と多くの優れた提案を与えてもらった。

### 日本語版への謝辞

本ドキュメントの日本語訳は、[@appigram](http://github.com/appigram)と[@scova0731](https://github.com/scova0731)が担当しました。

翻訳にあたっては、日本のScalaコミュニティから数多くの貢献を頂きました: [@xuwei-k](http://github.com/xuwei-k)さん、[@kmizu](http://github.com/kmizu)さん、[@eed3si9n](http://github.com/eed3si9n)さん、[@akr4](http://github.com/akr4)さん、[@yosuke-furukawa](http://github.com/yosuke-furukawa)さん、m hanadaさん、および[日本Scalaユーザーズグループ](http://jp.scala-users.org/)の皆さん。（以上、順不同）

また、[@kmizu](http://github.com/kmizu)さんと[@eed3si9n](http://github.com/eed3si9n)さんには、高度に専門的な議論について貴重な助言を頂きました。

ありがとうございます。

[Scala]: http://www.scala-lang.org/
[Finagle]: http://github.com/twitter/finagle
[Util]: http://github.com/twitter/util
